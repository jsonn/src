void
ncr53c9x_scsipi_request(chan, req, arg)
	struct scsipi_channel *chan;
	scsipi_adapter_req_t req;
	void *arg;
{
	struct scsipi_xfer *xs;
	struct scsipi_periph *periph;
	struct ncr53c9x_softc *sc = (void *)chan->chan_adapter->adapt_dev;
	struct ncr53c9x_ecb *ecb;
	int s, flags;

	NCR_TRACE(("[ncr53c9x_scsipi_request] "));

	switch (req) {
	case ADAPTER_REQ_RUN_XFER:
		xs = arg;
		periph = xs->xs_periph;
		flags = xs->xs_control;

		NCR_CMDS(("[0x0, 0]->0 ", (int)xs->cmd->opcode, xs->cmdlen,
		    periph->periph_target));

		/* Get an ECB to use. */
		ecb = ncr53c9x_get_ecb(sc);
#ifdef DIAGNOSTIC
		/*
		 * This should never happen as we track resources
		 * in the mid-layer.
		 */
		if (ecb == NULL) {
			scsipi_printaddr(periph);
			printf("unable to allocate ecb\n");
			panic("ncr53c9x_scsipi_request");
		}
#endif

		/* Initialize ecb */
		ecb->xs = xs;
		ecb->timeout = xs->timeout;

		if (flags & XS_CTL_RESET) {
			ecb->flags |= ECB_RESET;
			ecb->clen = 0;
			ecb->dleft = 0;
		} else {
			bcopy(xs->cmd, &ecb->cmd.cmd, xs->cmdlen);
			ecb->clen = xs->cmdlen;
			ecb->daddr = xs->data;
			ecb->dleft = xs->datalen;
		}
		ecb->stat = 0;

		s = splbio();

		TAILQ_INSERT_TAIL(&sc->ready_list, ecb, chain);
		if (sc->sc_state == NCR_IDLE)
			ncr53c9x_sched(sc);

		splx(s);

		if ((flags & XS_CTL_POLL) == 0)
			return;

		/* Not allowed to use interrupts, use polling instead */
		if (ncr53c9x_poll(sc, xs, ecb->timeout)) {
			ncr53c9x_timeout(ecb);
			if (ncr53c9x_poll(sc, xs, ecb->timeout))
				ncr53c9x_timeout(ecb);
		}
		return;

	case ADAPTER_REQ_GROW_RESOURCES:
		/* XXX Not supported. */
		return;

	case ADAPTER_REQ_SET_XFER_MODE:
	    {
		struct ncr53c9x_tinfo *ti;
		struct scsipi_xfer_mode *xm = arg;

		ti = &sc->sc_tinfo[xm->xm_target];
		ti->flags &= ~(T_NEGOTIATE|T_SYNCMODE);
		ti->period = 0;
		ti->offset = 0;

		if ((xm->xm_mode & PERIPH_CAP_SYNC) != 0 &&
		    sc->sc_minsync != 0 &&
		    (sc->sc_cfflags &
		     (1 << (xm->xm_target + 8))) == 0) {
			ti->flags |= T_NEGOTIATE;
			ti->period = sc->sc_minsync;
		}

		/*
		 * If we're not going to negotiate, send the notification
		 * now, since it won't happen later.
		 */
		if ((ti->flags & T_NEGOTIATE) == 0)
			ncr53c9x_update_xfer_mode(sc, xm->xm_target);
		return;
	    }
	}
}

void
ncr53c9x_update_xfer_mode(sc, target)
	struct ncr53c9x_softc *sc;
	int target;
{
	struct scsipi_xfer_mode xm;
	struct ncr53c9x_tinfo *ti = &sc->sc_tinfo[target];

	xm.xm_target = target;
	xm.xm_mode = 0;
	xm.xm_period = 0;
	xm.xm_offset = 0;

	if (ti->flags & T_SYNCMODE) {
		xm.xm_mode |= PERIPH_CAP_SYNC;
		xm.xm_period = ti->period;
		xm.xm_offset = ti->offset;
	}

	scsipi_async_event(&sc->sc_channel, ASYNC_EVENT_XFER_MODE, &xm);
}

