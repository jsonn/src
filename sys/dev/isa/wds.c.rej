***************
*** 662,708 ****
   * the hash table too otherwise either return an error or sleep.
   */
  struct wds_scb *
- wds_get_scb(sc, flags)
  	struct wds_softc *sc;
- 	int flags;
  {
  	struct wds_scb *scb;
  	int s;
  
  	s = splbio();
- 
- 	/*
- 	 * If we can and have to, sleep waiting for one to come free
- 	 * but only if we can't allocate a new one.
- 	 */
- 	for (;;) {
- 		scb = sc->sc_free_scb.tqh_first;
- 		if (scb) {
- 			TAILQ_REMOVE(&sc->sc_free_scb, scb, chain);
- 			break;
- 		}
- 		if (sc->sc_numscbs < WDS_SCB_MAX) {
- 			/*
- 			 * wds_create_scbs() might have managed to create
- 			 * one before it failed.  If so, don't abort,
- 			 * just grab it and continue to hobble along.
- 			 */
- 			if (wds_create_scbs(sc, NULL, 0) != 0 &&
- 			    sc->sc_free_scb.tqh_first == NULL) {
- 				printf(": can't allocate scbs\n",
- 				    sc->sc_dev.dv_xname);
- 				goto out;
- 			}
- 			continue;
- 		}
- 		if ((flags & XS_CTL_NOSLEEP) != 0)
- 			goto out;
- 		tsleep(&sc->sc_free_scb, PRIBIO, "wdsscb", 0);
  	}
- 
- 	scb->flags |= SCB_ALLOC;
- 
- out:
  	splx(s);
  	return (scb);
  }
--- 649,666 ----
   * the hash table too otherwise either return an error or sleep.
   */
  struct wds_scb *
+ wds_get_scb(sc)
  	struct wds_softc *sc;
  {
  	struct wds_scb *scb;
  	int s;
  
  	s = splbio();
+ 	scb = TAILQ_FIRST(&sc->sc_free_scb);
+ 	if (scb != NULL) {
+ 		TAILQ_REMOVE(&sc->sc_free_scb, scb, chain);
+ 		scb->flags |= SCB_ALLOC;
  	}
  	splx(s);
  	return (scb);
  }
***************
*** 1164,1388 ****
  /*
   * Send a SCSI command.
   */
- int
- wds_scsi_cmd(xs)
- 	struct scsipi_xfer *xs;
  {
- 	struct scsipi_link *sc_link = xs->sc_link;
- 	struct wds_softc *sc = sc_link->adapter_softc;
  	bus_dma_tag_t dmat = sc->sc_dmat;
  	struct wds_scb *scb;
  	struct wds_scat_gath *sg;
  	int error, seg, flags, s;
- 	int fromqueue = 0, dontqueue = 0;
- #ifdef TFS
- 	struct iovec *iovp;
- #endif
- 
- 	if (xs->xs_control & XS_CTL_RESET) {
- 		/* XXX Fix me! */
- 		printf(": reset!\n", sc->sc_dev.dv_xname);
- 		wds_init(sc, 1);
- 		return COMPLETE;
- 	}
  
- 	s = splbio();		/* protect the queue */
- 
- 	/*
- 	 * If we're running the queue from wds_done(), we've been
- 	 * called with the first queue entry as our argument.
- 	 */
- 	if (xs == TAILQ_FIRST(&sc->sc_queue)) {
- 		TAILQ_REMOVE(&sc->sc_queue, xs, adapter_q);
- 		fromqueue = 1;
- 		goto get_scb;
- 	}
- 
- 	/* Polled requests can't be queued for later. */
- 	dontqueue = xs->xs_control & XS_CTL_POLL;
  
- 	/*
- 	 * If there are jobs in the queue, run them first.
- 	 */
- 	if (TAILQ_FIRST(&sc->sc_queue) != NULL) {
- 		/*
- 		 * If we can't queue, we have to abort, since
- 		 * we have to preserve order.
- 		 */
- 		if (dontqueue) {
- 			splx(s);
  			xs->error = XS_DRIVER_STUFFUP;
- 			return (TRY_AGAIN_LATER);
  		}
  
- 		/*
- 		 * Swap with the first queue entry.
- 		 */
- 		TAILQ_INSERT_TAIL(&sc->sc_queue, xs, adapter_q);
- 		xs = TAILQ_FIRST(&sc->sc_queue);
- 		TAILQ_REMOVE(&sc->sc_queue, xs, adapter_q);
- 		fromqueue = 1;
- 	}
  
-  get_scb:
- 	flags = xs->xs_control;
- 	if ((scb = wds_get_scb(sc, flags)) == NULL) {
  		/*
- 		 * If we can't queue, we lose.
  		 */
- 		if (dontqueue) {
- 			splx(s);
- 			xs->error = XS_DRIVER_STUFFUP;
- 			return (TRY_AGAIN_LATER);
  		}
- 
- 		/*
- 		 * Stuff ourselves into the queue, in front
- 		 * if we came off in the first place.
- 		 */
- 		if (fromqueue)
- 			TAILQ_INSERT_HEAD(&sc->sc_queue, xs, adapter_q);
- 		else
- 			TAILQ_INSERT_TAIL(&sc->sc_queue, xs, adapter_q);
- 		splx(s);
- 		return (SUCCESSFULLY_QUEUED);
- 	}
- 
- 	splx(s);		/* done playing with the queue */
  
- 	scb->xs = xs;
- 	scb->timeout = xs->timeout;
  
- 	if (xs->xs_control & XS_CTL_DATA_UIO) {
- 		/* XXX Fix me! */
- 		/* Let's not worry about UIO. There isn't any code for the *
- 		 * non-SG boards anyway! */
- 		printf(": UIO is untested and disabled!\n",
- 		    sc->sc_dev.dv_xname);
- 		goto bad;
- 	}
  
- 	/* Zero out the command structure. */
- 	bzero(&scb->cmd, sizeof scb->cmd);
- 	bcopy(xs->cmd, &scb->cmd.scb, xs->cmdlen < 12 ? xs->cmdlen : 12);
- 
- 	/* Set up some of the command fields. */
- 	scb->cmd.targ = (xs->sc_link->scsipi_scsi.target << 5) |
- 						xs->sc_link->scsipi_scsi.lun;
- 
- 	/* NOTE: cmd.write may be OK as 0x40 (disable direction checking)
- 	 * on boards other than the WD-7000V-ASE. Need this for the ASE:
-  	 */
- 	scb->cmd.write = (xs->xs_control & XS_CTL_DATA_IN) ? 0x80 : 0x00;
  
- 	if (xs->datalen) {
- 		sg = scb->scat_gath;
- 		seg = 0;
  #ifdef TFS
- 		if (flags & XS_CTL_DATA_UIO) {
- 			error = bus_Dmamap_load_uio(dmat,
- 			    scb->dmamap_xfer, (struct uio *)xs->data,
- 			    (flags & XS_CTL_NOSLEEP) ? BUS_DMA_NOWAIT :
- 			    BUS_DMA_WAITOK);
- 		} else
  #endif /* TFS */
- 		{
- 			error = bus_dmamap_load(dmat,
- 			    scb->dmamap_xfer, xs->data, xs->datalen, NULL,
- 			    (flags & XS_CTL_NOSLEEP) ? BUS_DMA_NOWAIT :
- 			    BUS_DMA_WAITOK);
- 		}
  
- 		if (error) {
- 			if (error == EFBIG) {
- 				printf(": wds_scsi_cmd, more than 0"
- 				    " dma segments\n",
- 				    sc->sc_dev.dv_xname, sc->sc_maxsegs);
- 			} else {
- 				printf(": wds_scsi_cmd, error 0 loading"
- 				    " dma map\n",
  				    sc->sc_dev.dv_xname, error);
  			}
- 			goto bad;
- 		}
  
- 		bus_dmamap_sync(dmat, scb->dmamap_xfer, 0,
- 		    scb->dmamap_xfer->dm_mapsize,
- 		    (flags & XS_CTL_DATA_IN) ? BUS_DMASYNC_PREREAD :
- 		    BUS_DMASYNC_PREWRITE);
  
- 		if (sc->sc_maxsegs > 1) {
- 			/*
- 			 * Load the hardware scatter/gather map with the
- 			 * contents of the DMA map.
- 			 */
- 			for (seg = 0; seg < scb->dmamap_xfer->dm_nsegs;
- 			    seg++) {
  				ltophys(scb->dmamap_xfer->dm_segs[seg].ds_addr,
- 				    scb->scat_gath[seg].seg_addr);
  				ltophys(scb->dmamap_xfer->dm_segs[seg].ds_len,
- 				    scb->scat_gath[seg].seg_len);
  			}
  
- 			/*
- 			 * Set up for scatter/gather transfer.
- 			 */
- 			scb->cmd.opcode = WDSX_SCSISG;
- 			ltophys(scb->dmamap_self->dm_segs[0].ds_addr +
- 			    offsetof(struct wds_scb, scat_gath),
- 			    scb->cmd.data);
- 			ltophys(scb->dmamap_self->dm_nsegs *
- 			    sizeof(struct wds_scat_gath), scb->cmd.len);
  		} else {
  			/*
- 			 * This board is an ASC or an ASE, and the
- 			 * transfer has been mapped contig for us.
  			 */
- 			scb->cmd.opcode = WDSX_SCSICMD;
- 			ltophys(scb->dmamap_xfer->dm_segs[0].ds_addr,
- 			    scb->cmd.data);
- 			ltophys(scb->dmamap_xfer->dm_segs[0].ds_len,
- 			    scb->cmd.len);
  		}
- 	} else {
- 		scb->cmd.opcode = WDSX_SCSICMD;
- 		ltophys(0, scb->cmd.data);
- 		ltophys(0, scb->cmd.len);
- 	}
  
- 	scb->cmd.stat = 0x00;
- 	scb->cmd.venderr = 0x00;
- 	ltophys(0, scb->cmd.link);
- 
- 	/* XXX Do we really want to do this? */
- 	if (flags & XS_CTL_POLL) {
- 		/* Will poll card, await result. */
- 		bus_space_write_1(sc->sc_iot, sc->sc_ioh, WDS_HCR, WDSH_DRQEN);
- 		scb->flags |= SCB_POLLED;
- 	} else {
- 		/* Will send command, let interrupt routine handle result. */
- 		bus_space_write_1(sc->sc_iot, sc->sc_ioh, WDS_HCR,
- 		    WDSH_IRQEN | WDSH_DRQEN);
- 	}
- 
- 	s = splbio();
- 	wds_queue_scb(sc, scb);
- 	splx(s);
  
- 	if ((flags & XS_CTL_POLL) == 0)
- 		return SUCCESSFULLY_QUEUED;
  
- 	if (wds_poll(sc, xs, scb->timeout)) {
- 		wds_timeout(scb);
- 		if (wds_poll(sc, xs, scb->timeout))
  			wds_timeout(scb);
- 	}
- 	return COMPLETE;
  
- bad:
- 	xs->error = XS_DRIVER_STUFFUP;
- 	wds_free_scb(sc, scb);
- 	return COMPLETE;
  }
  
  /*
--- 1110,1311 ----
  /*
   * Send a SCSI command.
   */
+ void
+ wds_scsipi_request(chan, req, arg)
+ 	struct scsipi_channel *chan;
+ 	scsipi_adapter_req_t req;
+ 	void *arg;
  {
+ 	struct scsipi_xfer *xs;
+ 	struct scsipi_periph *periph;
+ 	struct wds_softc *sc = (void *)chan->chan_adapter->adapt_dev;
  	bus_dma_tag_t dmat = sc->sc_dmat;
  	struct wds_scb *scb;
  	struct wds_scat_gath *sg;
  	int error, seg, flags, s;
  
+ 	switch (req) {
+ 	case ADAPTER_REQ_RUN_XFER:
+ 		xs = arg;
+ 		periph = xs->xs_periph;
+ 
+ 		if (xs->xs_control & XS_CTL_RESET) {
+ 			/* XXX Fix me! */
+ 			printf(": reset!\n", sc->sc_dev.dv_xname);
+ 			wds_init(sc, 1);
+ 			scsipi_done(xs);
+ 			return;
+ 		}
  
+ 		if (xs->xs_control & XS_CTL_DATA_UIO) {
+ 			/* XXX Fix me! */
+ 			/*
+ 			 * Let's not worry about UIO. There isn't any code
+ 			 * for the non-SG boards anyway!
+ 			 */
+ 			printf(": UIO is untested and disabled!\n",
+ 			    sc->sc_dev.dv_xname);
  			xs->error = XS_DRIVER_STUFFUP;
+ 			scsipi_done(xs);
+ 			return;
  		}
  
+ 		flags = xs->xs_control;
  
+ 		/* Get an SCB to use. */
+ 		scb = wds_get_scb(sc);
+ #ifdef DIAGNOSTIC
  		/*
+ 		 * This should never happen as we track the resources
+ 		 * in the mid-layer.
  		 */
+ 		if (scb == NULL) {
+ 			scsipi_printaddr(periph);
+ 			printf("unable to allocate scb\n");
+ 			panic("wds_scsipi_request");
  		}
+ #endif
  
+ 		scb->xs = xs;
+ 		scb->timeout = xs->timeout;
  
+ 		/* Zero out the command structure. */
+ 		bzero(&scb->cmd, sizeof scb->cmd);
+ 		bcopy(xs->cmd, &scb->cmd.scb,
+ 		    xs->cmdlen < 12 ? xs->cmdlen : 12);
+ 
+ 		/* Set up some of the command fields. */
+ 		scb->cmd.targ = (periph->periph_target << 5) |
+ 		    periph->periph_lun;
  
+ 		/*
+ 		 * NOTE: cmd.write may be OK as 0x40 (disable direction
+ 		 * checking) on boards other than the WD-7000V-ASE. Need
+ 		 * this for the ASE:
+  		 */
+ 		scb->cmd.write = (xs->xs_control & XS_CTL_DATA_IN) ?
+ 		    0x80 : 0x00;
  
+ 		if (xs->datalen) {
+ 			sg = scb->scat_gath;
+ 			seg = 0;
  #ifdef TFS
+ 			if (flags & XS_CTL_DATA_UIO) {
+ 				error = bus_dmamap_load_uio(dmat,
+ 				    scb->dmamap_xfer, (struct uio *)xs->data,
+ 				    BUS_DMA_NOWAIT);
+ 			} else
  #endif /* TFS */
+ 			{
+ 				error = bus_dmamap_load(dmat,
+ 				    scb->dmamap_xfer, xs->data, xs->datalen,
+ 				    NULL, BUS_DMA_NOWAIT);
+ 			}
  
+ 			switch (error) {
+ 			case 0:
+ 				break;
+ 
+ 			case ENOMEM:
+ 			case EAGAIN:
+ 				xs->error = XS_RESOURCE_SHORTAGE;
+ 				goto out_bad;
+ 
+ 			default:
+ 				xs->error = XS_DRIVER_STUFFUP;
+ 				printf(": error 0 loading DMA map\n",
  				    sc->sc_dev.dv_xname, error);
+  out_bad:
+ 				wds_free_scb(sc, scb);
+ 				scsipi_done(xs);
+ 				return;
  			}
  
+ 			bus_dmamap_sync(dmat, scb->dmamap_xfer, 0,
+ 			    scb->dmamap_xfer->dm_mapsize,
+ 			    (flags & XS_CTL_DATA_IN) ? BUS_DMASYNC_PREREAD :
+ 			    BUS_DMASYNC_PREWRITE);
  
+ 			if (sc->sc_maxsegs > 1) {
+ 				/*
+ 				 * Load the hardware scatter/gather map with the
+ 				 * contents of the DMA map.
+ 				 */
+ 				for (seg = 0;
+ 				     seg < scb->dmamap_xfer->dm_nsegs; seg++) {
  				ltophys(scb->dmamap_xfer->dm_segs[seg].ds_addr,
+ 					    scb->scat_gath[seg].seg_addr);
  				ltophys(scb->dmamap_xfer->dm_segs[seg].ds_len,
+ 					    scb->scat_gath[seg].seg_len);
+ 				}
+ 
+ 				/*
+ 				 * Set up for scatter/gather transfer.
+ 				 */
+ 				scb->cmd.opcode = WDSX_SCSISG;
+ 				ltophys(scb->dmamap_self->dm_segs[0].ds_addr +
+ 				    offsetof(struct wds_scb, scat_gath),
+ 				    scb->cmd.data);
+ 				ltophys(scb->dmamap_self->dm_nsegs *
+ 				    sizeof(struct wds_scat_gath), scb->cmd.len);
+ 			} else {
+ 				/*
+ 				 * This board is an ASC or an ASE, and the
+ 				 * transfer has been mapped contig for us.
+ 				 */
+ 				scb->cmd.opcode = WDSX_SCSICMD;
+ 				ltophys(scb->dmamap_xfer->dm_segs[0].ds_addr,
+ 				    scb->cmd.data);
+ 				ltophys(scb->dmamap_xfer->dm_segs[0].ds_len,
+ 				    scb->cmd.len);
  			}
+ 		} else {
+ 			scb->cmd.opcode = WDSX_SCSICMD;
+ 			ltophys(0, scb->cmd.data);
+ 			ltophys(0, scb->cmd.len);
+ 		}
  
+ 		scb->cmd.stat = 0x00;
+ 		scb->cmd.venderr = 0x00;
+ 		ltophys(0, scb->cmd.link);
+ 
+ 		/* XXX Do we really want to do this? */
+ 		if (flags & XS_CTL_POLL) {
+ 			/* Will poll card, await result. */
+ 			bus_space_write_1(sc->sc_iot, sc->sc_ioh,
+ 			    WDS_HCR, WDSH_DRQEN);
+ 			scb->flags |= SCB_POLLED;
  		} else {
  			/*
+ 			 * Will send command, let interrupt routine
+ 			 * handle result.
  			 */
+ 			bus_space_write_1(sc->sc_iot, sc->sc_ioh, WDS_HCR,
+ 			    WDSH_IRQEN | WDSH_DRQEN);
  		}
  
+ 		s = splbio();
+ 		wds_queue_scb(sc, scb);
+ 		splx(s);
  
+ 		if ((flags & XS_CTL_POLL) == 0)
+ 			return;
  
+ 		if (wds_poll(sc, xs, scb->timeout)) {
  			wds_timeout(scb);
+ 			if (wds_poll(sc, xs, scb->timeout))
+ 				wds_timeout(scb);
+ 		}
+ 		return;
  
+ 	case ADAPTER_REQ_GROW_RESOURCES:
+ 		/* XXX Not supported. */
+ 		return;
+ 
+ 	case ADAPTER_REQ_SET_XFER_MODE:
+ 		/* XXX How do we do this? */
+ 		return;
+ 	}
  }
  
  /*
