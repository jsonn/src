void
sea_scsipi_request(chan, req, arg)
	struct scsipi_channel *chan;
	scsipi_adapter_req_t req;
	void *arg;
{
	struct scsipi_xfer *xs;
	struct scsipi_periph *periph;
	struct sea_softc *sea = (void *)chan->chan_adapter->adapt_dev;
	struct sea_scb *scb;
	int flags;
	int s;

	switch (req) {
	case ADAPTER_REQ_RUN_XFER:
		xs = arg;
		periph = xs->xs_periph;
		flags = xs->xs_control;

		SC_DEBUG(periph, SCSIPI_DB2, ("sea_scsipi_requeset\n"));

		/* XXX Reset not implemented. */
		if (flags & XS_CTL_RESET) {
			printf(": resetting\n", sea->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			scsipi_done(xs);
			return;
		}

		/* Get an SCB to use. */
		scb = sea_get_scb(sea, flags);
#ifdef DIAGNOSTIC
		/*
		 * This should never happen as we track the resources
		 * in the mid-layer.
		 */
		if (scb == NULL) {
			scsipi_printaddr(periph);
			printf("unable to allocate scb\n");
			panic("sea_scsipi_request");
		}
#endif

		scb->flags = SCB_ACTIVE;
		scb->xs = xs;

		/*
		 * Put all the arguments for the xfer in the scb
		 */
		scb->datalen = xs->datalen;
		scb->data = xs->data;

#ifdef SEA_DEBUGQUEUE
		sea_queue_length(sea);
#endif

		s = splbio();

		sea_send_scb(sea, scb);

		if ((flags & XS_CTL_POLL) == 0) {
			timeout(sea_timeout, scb, (xs->timeout * hz) / 1000);
			splx(s);
			return;
		}

		splx(s);

		/*
		 * If we can't use interrupts, poll on completion
		 */
		if (sea_poll(sea, xs, xs->timeout)) {
			sea_timeout(scb);
			if (sea_poll(sea, xs, 2000))
				sea_timeout(scb);
		}
		return;

	case ADAPTER_REQ_GROW_RESOURCES:
		sea_grow_scb(sea);
		return;

	case ADAPTER_REQ_SET_XFER_MODE:
	    {
		struct scsipi_xfer_mode *xm = arg;

		/*
		 * We don't support sync or wide or tagged queueing,
		 * so announce that now.
		 */
		xm->xm_mode = 0;
		xm->xm_period = 0;
		xm->xm_offset = 0;
		scsipi_async_event(chan, ASYNC_EVENT_XFER_MODE, xm);
		return;
	    }
	}
}

/*
 * Allocate an scb and add it to the free list.
 * We are called at splbio.
 */
void
sea_grow_scb(sea)
	struct sea_softc *sea;
{
	struct sea_scb *scb;

	if (sea->numscbs == SEA_SCB_MAX) {
		sea->sc_channel.chan_flags &= ~SCSIPI_CHAN_CANGROW;
		return;
	}

	scb = malloc(sizeof(struct sea_scb), M_DEVBUF, M_NOWAIT);
	if (scb == NULL)
		return;

	memset(scb, 0, sizeof(struct sea_scb));

	TAILQ_INSERT_TAIL(&sea->free_list, scb, chain);
	sea->numscbs++;
	sea->sc_adapter.adapt_openings++;
}
