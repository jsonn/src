#	$NetBSD: files.omap,v 1.4.6.5.4.1 2007/11/10 02:56:43 matt Exp $
#
# Configuration info for Texas Instruments OMAP CPU support
# Based on xscale/files.pxa2x0
#

file	arch/arm/arm/softintr.c  # Use the generic ARM soft interrupt code.
file	arch/arm/arm32/irq_dispatch.S

# Memory size in megabytes
defparam opt_omap.h				MEMSIZE
defparam opt_omap.h				OMAP_EMIFF_PBASE OMAP_EMIFF_SIZE
defflag opt_omap.h				OMAP_2430

# OBIO
# like tipb but no regs to program... just an attach point
device obio { [addr=-1], [size=0], [intr=-1], [mult=1], [nobyteacc=0]
	     } : bus_space_generic
attach obio at mainbus
file	arch/arm/omap/omap_obio.c		obio needs-count

# Texas Instruments Peripheral Bus.
# addr: Address of the peripheral in the OMAP address space
# size: Number of bytes that the peripheral occupies in the OMAP address space
# intr: Interrupts connected to the first level interrupt controller should
#	give the first level interrupt controller's number.  Interrupts
#	connected to the second level interrupt controller should give the
#	second level interrupt controller's number plus 32 (the number of
#	interrupts that the first level controller has).
# mult: Used to multiply the offsets given within a driver.  For example, if
#	the driver expects byte registers at byte offsets, but they are mapped
#	in at word offsets, a mult of 4 would be specified.  Note that the
#	size parameter is not multiplied by mult.  If you specify a mult, in
#	general, you should probably be specifying a size to ensure that the
#	correct amount is mapped.
device tipb { [addr=-1], [size=0], [intr=-1], [mult=1] } : bus_space_generic
attach tipb at mainbus
file	arch/arm/omap/omap_tipb.c		tipb
defparam opt_omap.h				OMAP_TIPB_PBASE OMAP_TIPB_SIZE
file	arch/arm/omap/omap_dma.c

# Extended Memory Interface Slow
# Same parameters as for TIPB, but with the addition of parameters to
# configure bus access.  A parameter is provided to to force halfword access
# instead of byte accesses:
#    nobyteacc: Allow 8-bit access for device with no lsb address line
# If this is set to 1, if an attempt is made to write a single byte to the
# bus, it will automatically get converted into reading a halfword, setting
# the byte that is being written into the appropriate byte of the halfword,
# and then writing the halfword to the bus.
#
# In addition to the nobyteacc parameter, a number of parameters are provided
# to configure bus timing via the EMIFS_CCS and EMIFS_ACS registers.  The cs
# parameter specifies which chip-select should have its configuration
# modified.
#
# NOTE: If the cs parameter is not specified, the EMIFS_CCS and EMIFS_ACS
# registers will not be modified and all of the bus timing parameters will be
# ignored.
#
# When cs is specified, EMIFS_CCS and EMIFS_ACS will be modified.  In addition
# to cs on your emifs device, you must specify the base parameter on the emifs
# bus to tell it where its registers are.  All fields of the EMIFS_CCS and
# EMIFS_ACS registers will be set.  The EMIFS will be set to be:
#
#	asynchronous, non-page mode (RDMODE = 0)
#	non-multiplexed protocol
#	16 bit wide
#	REF_CLK = TC_CK / 1
#
# The timing parameters are rdwst, oesetup, oehold, wrwst, welen, advhold,
# btwst and btmode.  All of them specify a number of nanoseconds, except
# btmode which is a simple 0/1 flag.
#
# For a read cycle, CS will be held low for rdwst nanoseconds.  The delay from
# driving CS low to driving OE low is specified by oesetup.  OE will go back
# high oehold nanoseconds before CS goes back high.
#
# For a write cycle, CS will be held low for wrwst (time before WE goes low) +
# welen (time WE is held low) + 1 REF_CLK cycle (time after WE goes high).
#
# For both read and write, advhold specifies how long ADV should be remain low
# after it is driven low at the same time as CS.
#
# The bus turn around time (amount of time that CS needs to be high between
# accesses) is specified by btwst and btmode.  See the TRM for more
# information.
#
# If btmode is not specified, it will be set to 0.  All other timing
# parameters will default to their minimum value.
#
device emifs { [addr=-1], [size=0], [intr=-1], [mult=1], [nobyteacc=0],
	       [cs=-1], [rdwst=0], [oesetup=0], [oehold=0],
	       [wrwst=0], [welen=0], [advhold=0], [btwst=0], [btmode=0]
	     } : bus_space_generic
attach emifs at mainbus
defparam opt_omap.h				OMAP_EMIFS_PBASE OMAP_EMIFS_SIZE
file	arch/arm/omap/omap_emifs.c		emifs
defparam opt_omap.h				OMAP_TC_CLOCK_FREQ

# OCP
device ocp { [addr=-1], [size=0], [intr=-1], [mult=1]} : bus_space_generic
attach ocp at mainbus
defparam opt_omap.h				OMAP_OCP_T1_PBASE OMAP_OCP_T1_SIZE
defparam opt_omap.h				OMAP_OCP_T2_PBASE OMAP_OCP_T2_SIZE
file	arch/arm/omap/omap_ocp.c		ocp

# TIPB/EMIFS/OCP common files
file	arch/arm/omap/omap_space.c		obio | tipb | emifs | ocp
file	arch/arm/omap/omap_a2x_space.c		obio | tipb | emifs | ocp
file	arch/arm/omap/omap_a2x_io.S		obio | tipb | emifs | ocp
file	arch/arm/omap/omap_a4x_space.c		obio | tipb | emifs | ocp
file	arch/arm/xscale/pxa2x0_a4x_io.S		obio | tipb | emifs | ocp

# NS16550 compatible serial ports
attach com at tipb with omapuart
file	arch/arm/omap/omap_com.c		omapuart
defparam opt_com.h				CONSADDR CONSPEED CONMODE

# INTC controller
define omapintc
file	arch/arm/omap/omap_intr.c		omapintc
# OMAP5912 specific INTC controller code
device omap5912intc: omapintc
attach omap5912intc at tipb
file	arch/arm/omap/omap5912_intr.c		omap5912intc
# OMAP2430 specific INTC controller code
file	arch/arm/omap/omap2430_intr.c		omap_2430

# OMAP1 MPU Timer
device omapmputmr
attach omapmputmr at tipb
file	arch/arm/omap/omap_mputmr.c		omapmputmr
defparam opt_omap.h				OMAP_MPU_TIMER_CLOCK_FREQ

# OMAP 2430 General Purpose Timer
device omap2430mputmr
file	arch/arm/omap/omap2430_mputmr.c		omap2430mputmr
defparam opt_omap.h				OMAP_GP_TIMER_CLOCK_FREQ

# OBIO/2430 GP Timer
attach omap2430mputmr at obio with obiomputmr
file	arch/arm/omap/obio_mputmr.c		obiomputmr

# RTC
device omaprtc
attach omaprtc at tipb
file arch/arm/omap/omap_rtc.c			omaprtc

# Dual Mode (General Purpose) Timer
device omapgptmr
attach omapgptmr at obio
file	arch/arm/omap/omap_gptmr.c		omapgptmr
file	arch/arm/omap/omap_pwm.c		omapgptmr

# OMAP GPIO Block
device omapgpio
attach omapgpio at tipb
file  arch/arm/omap/omap_gpio.c       omapgpio	needs-count

# OMAP GPIO Bus
device	omapiobus: gpiobus
attach	omapiobus at tipb
file	arch/arm/omap/omap_iobus.c		omapiobus

# OMAP I2C controller
device	omapi2c: i2cbus
attach	omapi2c at tipb
file	arch/arm/omap/omap_i2c.c		omapi2c
defparam	opt_omap.h		OMAP_I2C_ADDRESS
defparam	opt_omap.h		I2C_LOW_TIME_nSEC
defparam	opt_omap.h		I2C_HIGH_TIME_nSEC

#attach udc at tipb with omapudc
#file	arch/arm/omap/omap_udc.c		omapudc

# OMAP McBsp controller

device	omapmcbsp
attach	omapmcbsp at tipb
file	arch/arm/omap/omap_mcbsp.c	omapmcbsp

# Watchdog timers

device omapwdt32k: sysmon_wdog
file arch/arm/omap/omap_wdt.c			omapwdt32k needs-flag

attach omapwdt32k at tipb with tipbwdt32k
file arch/arm/omap/tipb_wdt.c			tipbwdt32k

attach omapwdt32k at obio with obiowdt32k
file arch/arm/omap/obio_wdt.c			obiowdt32k

# Hardware clock and power management

device omapdpll
attach omapdpll at tipb
device omapmpuclkm
attach omapmpuclkm at tipb
device omapulpd
attach omapulpd at tipb
device omapconfig
attach omapconfig at tipb

file arch/arm/omap/hwclock_omap1.c	hwclock
defparam	opt_hwclock_machine.h		OMAP_CK_REF_SPEED

# L3 Interconnect
device L3i { [addr=-1], [size=0], [intr=-1], [mult=1], [nobyteacc=0]
	     } : bus_space_generic
attach L3i at mainbus
file	arch/arm/omap/omap_L3i.c			omap_2430

# General Purpose Memory Controller
# XXX some addl. chip select config parms may be desired here (e.g. timing)
# XXX so far we just use the setup established by boot firmware
device gpmc { [addr=-1], [size=0], [intr=-1], [mult=1], [nobyteacc=0]
	     } : bus_space_generic
attach gpmc at mainbus
file	arch/arm/omap/omap_gpmc.c		gpmc

# these bus space methods are not bus-specific ...
#
file	arch/arm/omap/omap_nobyteacc_space.c	emifs | gpmc
file	arch/arm/omap/omap_nobyteacc_io.S	emifs | gpmc
