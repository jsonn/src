#!/bin/sh -
#
#	$NetBSD: MAKEDEV,v 1.51.2.1 2002/08/10 00:06:19 lukem Exp $
#
#	from: @(#)MAKEDEV	8.1 (Berkeley) 6/9/93
#
###########################################################################
#
#   PLEASE RUN "cd ../share/man/man8 ; perl5 MAKEDEV2manpage.pl"
#   AFTER CHANGING THIS FILE, AND COMMIT THE UPDATED MANPAGE!
#
###########################################################################
#

# Device "make" file.  Valid arguments:
#	all	all known devices, including local devices.
#	minimal A minimal set of devices for install disks, etc.
#	std	standard devices
#	local	configuration specific devices
# Tapes:
#	st*	MI SCSI tape drives
# Disks:
#	ccd*	concatenated disk driver
#	cd*	MI SCSI cdroms
#	md*	memory pseudo-disk devices
#	raid*	RAIDframe disk driver
#	sd*	MI SCSI disks
#	vnd*	"file" pseudo-disks
# Terminal multiplexors:
#	dc*	4 channel serial interface (keyboard, mouse, modem, printer)
#	scc*	82530 serial interface
# Pseudo terminals:
#	pty*	set of 62 master and slave pseudo terminals
#	opty	first 16 ptys, to save inodes on install media
# Special purpose devices:
#	clockctl clock control for non root users
#	audio*	phone-quality audio on Personal DECstations
#	bpf*	packet filter
#	ch*	SCSI media changer
#	fd	file descriptors (/dev/fd/*)
#	ipl	IP packet filter
#	lkm	loadable kernel modules interface    (unsupported in 1.3_ALPHA)
#	random	Random number generator
#	scsibus* SCSI busses, see scsi(4), scsictl(8)
#	ss*	SCSI scanner
#	tun*	network tunnel driver
#	uk*	unknown SCSI device
# Platform-specific devices:
#	NOTE: /dev/mouse should be a link to one of these for X windows.
#	fb*	generic framebuffer pseudo-device
#	px*	PixelStamp Xserver access
# The following names are reserved for future use:
#	fdc*	Baseboard 2.88 floppy disk on Personal DECstations
#	ttyE?	Workstation console ("wscons") glass-tty emulators
#


PATH=/sbin:/bin/:/usr/bin:/usr/sbin
umask 77

# Check if we have fdesc mounted
if [ -d fd ]; then
	case "`df fd`" in
	*fdesc*) nofdesc=false;;
	*) nofdesc=true;;
	esac
else
	nofdesc=true
fi

makedev()
{

for i
do
case $i in

all)
	makedev minimal fd
	makedev raid0 raid1 raid2 raid3 raid4 raid5 raid6 raid7
	makedev pty0 vnd0 vnd1 vnd2 vnd3 ccd0 ccd1 ccd2 ccd3
	makedev tun0 tun1 tun2 tun3
	makedev bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7
	makedev fb0 fb1 fb2
	makedev px0 # px1 px2
	makedev mouse
	makedev ipl random lkm
	makedev local
	makedev audio
	makedev scsibus0 scsibus1 scsibus2 scsibus3
	makedev clockctl
	;;

minimal)
	makedev std
	makedev cd0
	makedev sd0 sd1 sd2 sd3 sd4 sd5 sd6 sd7
	makedev sd8 sd9 sd10 sd11 sd12 sd13 sd14 sd15
	makedev st0 st1
	makedev md0 dz0 zs0 opty
	;;

std)
	rm -f console drum kmem mem null zero klog
	mknod console		c 0 0
	mknod drum		c 1 0	; chmod 640 drum ; chgrp kmem drum
	mknod kmem		c 3 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 3 2	; chmod 666 null
	mknod zero		c 3 12	; chmod 666 zero
	mknod klog		c 6 0	; chmod 600 klog
	if $nofdesc; then
		rm -f tty stdin stdout stderr
		mknod tty	c 2 0	; chmod 666 tty
		mknod stdin	c 7 0	; chmod 666 stdin
		mknod stdout	c 7 1	; chmod 666 stdout
		mknod stderr	c 7 2	; chmod 666 stderr
	fi
	;;

fd)
	if $nofdesc; then
		rm -f fd/*
		mkdir fd 2>/dev/null
		n=0
		while [ $n -lt 64 ]; do
			mknod fd/$n c 7 $n
			n=$(($n + 1))
		done
		chmod 755 fd
		chmod 666 fd/*
	fi
	;;

audio)
	makedev audio0
	ln -fs sound0 sound
	ln -fs audio0 audio
	ln -fs mixer0 mixer
	ln -fs audioctl0 audioctl
	;;

bpf*|tun*)
	case $i in
	bpf*) name=bpf; unit=${i#bpf};	chr=12;;
	tun*) name=tun; unit=${i#tun};	chr=93;;
	esac
	rm -f $name$unit
	mknod $name$unit c $chr $unit
	chmod 600 $name$unit
	;;

lkm)
	rm -f lkm
	mknod lkm c 94 0
	chgrp kmem lkm
	chmod 640 lkm
	;;

audio*)
	unit=${i#audio}
	audio=audio$unit
	sound=sound$unit
	mixer=mixer$unit
	major=99
	audioctl=audioctl$unit
	if [ "$unit" = "" ]; then unit=0; fi
	rm -f $audio $sound $mixer $audioctl
	mknod $sound    c $major $(($unit + 0))
	mknod $audio    c $major $(($unit + 128))
	mknod $mixer    c $major $(($unit + 16))
	mknod $audioctl c $major $(($unit + 192))
	chmod 666 $audio $sound $mixer $audioctl
	;;

md*)
	unit=${i#md}; blk=17; chr=97
	rm -f md${unit}? rmd${unit}?
	mknod md${unit}a  b $blk $(($unit * 8 + 0))
	mknod md${unit}c  b $blk $(($unit * 8 + 2))
#	mknod rmd${unit}a c $chr $(($unit * 8 + 0))
#	mknod rmd${unit}c c $chr $(($unit * 8 + 2))
	chgrp operator md${unit}? #rmd${unit}?
	chmod 640 md${unit}? #rmd${unit}?
	;;

ccd*|cd*|raid*|sd*|vnd*)
	case $i in
	ccd*)   name=ccd;       unit=${i#ccd};  blk=24; chr=87;;
	cd*)    name=cd;        unit=${i#cd};   blk=25; chr=47;;
	raid*)  name=raid;      unit=${i#raid}; blk=32; chr=96;;
	sd*)    name=sd;        unit=${i#sd};   blk=19; chr=9;;
	vnd*)   name=vnd;       unit=${i#vnd};  blk=2;  chr=11;;
	esac
	case $unit in
	[0-9]|1[0-5])
		rm -f ${name}${unit}[a-h] r${name}${unit}[a-h]
		mknod ${name}${unit}a	b $blk $(($unit * 8 + 0))
		mknod ${name}${unit}b	b $blk $(($unit * 8 + 1))
		mknod ${name}${unit}c	b $blk $(($unit * 8 + 2))
		mknod ${name}${unit}d	b $blk $(($unit * 8 + 3))
		mknod ${name}${unit}e	b $blk $(($unit * 8 + 4))
		mknod ${name}${unit}f	b $blk $(($unit * 8 + 5))
		mknod ${name}${unit}g	b $blk $(($unit * 8 + 6))
		mknod ${name}${unit}h	b $blk $(($unit * 8 + 7))
		mknod r${name}${unit}a	c $chr $(($unit * 8 + 0))
		mknod r${name}${unit}b	c $chr $(($unit * 8 + 1))
		mknod r${name}${unit}c	c $chr $(($unit * 8 + 2))
		mknod r${name}${unit}d	c $chr $(($unit * 8 + 3))
		mknod r${name}${unit}e	c $chr $(($unit * 8 + 4))
		mknod r${name}${unit}f	c $chr $(($unit * 8 + 5))
		mknod r${name}${unit}g	c $chr $(($unit * 8 + 6))
		mknod r${name}${unit}h	c $chr $(($unit * 8 + 7))
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	;;

# Serial devices: dc*, scc*.
#
#     Create dc* devices as /dev/ttyD[0-3],
#     for compatibility with NetBSD's vax  dc/dz driver.
dc*|dz*)
	case $i in
	dc*)		name=dc;	unit=${i#dc};	chr=16;;
	dz*)		name=dz;	unit=${i#dz};	chr=16;;
	esac
	case $unit in
	0)
		rm -f ttyD[0123]
		mknod ttyD0 c $chr 0
		mknod ttyD1 c $chr 1
		mknod ttyD2 c $chr 2
		mknod ttyD3 c $chr 3
		;;
	*)
		echo bad unit for $name in: $i
		;;
	esac
	;;

# Make scc devices as /dev/tty[abcd],
# for compatibility with NetBSD's MI zs tty  driver.
#
scc*|zs*)
	case $i in
	scc*)	name=scc;	unit=${i#scc};	chr=17;;
	zs*)	name=scc;	unit=${i#zs};	chr=17;;
	esac
	case $unit in
	0|1)
		rm -f tty[abcd]
		mknod ttya c $chr 0
		mknod ttyb c $chr 1
		mknod ttyc c $chr 2
		mknod ttyd c $chr 3
		;;
	*)
		echo bad unit for $name in: $i
		;;
	esac
	;;

fb*)
	unit=${i#fb}
	rm -f fb$unit
	mknod fb$unit c 86 $unit
	chmod 666 fb$unit
	;;

px*)
	unit=${i#px}
	rm -f px$unit
	mknod px$unit c 98 $unit
	chmod 666 px$unit
	;;

mouse)
	ln -fs fb0 mouse
	;;

opty)
	rm -f ttyp[0-9a-f] ptyp[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
	do
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		mknod ttyp$j c 4 $jn
		mknod ptyp$j c 5 $jn
	done
	chmod 666 ttyp[0-9a-f] ptyp[0-9a-f]
	;;

		
pty*)
	class=${i#pty}
	name=`echo pqrstuvwxyzPQRST | dd bs=1 count=1 skip=$class 2>/dev/null`
	case $name in
	v)	echo "$0: $i: pty unit conflicts with console ttyv0 device."
		continue;;
	?)      ;;
	*)      echo "$0: $i: pty unit must be between 0 and 15"
	        continue ;;
	esac
	rm -f tty$name[0-9a-zA-Z] pty$name[0-9a-zA-Z]
	jn=0
	while [ $jn -lt 62 ]
	do
		j=`echo 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ | dd bs=1 count=1 skip=$jn 2>/dev/null`
		skip=0
		if [ $jn -ge 16 ]; then
			skip=$(($class * 30 + 256 - 16))
		fi
		unit=$(($class * 16 + $jn + $skip))
		mknod tty$name$j c 4 $unit
		mknod pty$name$j c 5 $unit
		jn=$(($jn + 1))
	done
	chmod 666 tty$name[0-9a-zA-Z] pty$name[0-9a-zA-Z]
	;;

ipl)
	rm -f ipl ipnat ipstate ipauth
	mknod ipl c 91 0
	mknod ipnat c 91 1
	mknod ipstate c 91 2
	mknod ipauth c 91 3
	chmod 600 ipl ipnat ipstate ipauth
	;;

random)
	rm -f random urandom
	mknod random c 92 0
	mknod urandom c 92 1
	chmod 444 random
	chmod 644 urandom
	;;

st*)
	case $i in
	st*) name=st;	unit=${i#st};	blk=18; chr=46;;
	esac
	rm -f $name$unit n$name$unit e$name$unit en$name$unit \
	r$name$unit nr$name$unit er$name$unit enr$name$unit
	mknod ${name}${unit}	b $blk $(($unit * 16+ 0))
	mknod n${name}${unit}	b $blk $(($unit * 16+ 1))
	mknod e${name}${unit}	b $blk $(($unit * 16+ 2))
	mknod en${name}${unit}	b $blk $(($unit * 16+ 3))
	mknod r${name}${unit}	c $chr $(($unit * 16+ 0))
	mknod nr${name}${unit}	c $chr $(($unit * 16+ 1))
	mknod er${name}${unit}	c $chr $(($unit * 16+ 2))
	mknod enr${name}${unit} c $chr $(($unit * 16+ 3))
	chgrp operator ${name}${unit} n${name}${unit} \
		e$name$unit en$name$unit \
		r${name}${unit} nr${name}${unit} \
		er${name}${unit} enr${name}${unit}
	chmod 660 ${name}${unit} n${name}${unit} \
		e$name$unit en$name$unit \
		r${name}${unit} nr${name}${unit} \
		er${name}${unit} enr${name}${unit}
	;;

ch*|uk*)
	case $i in
	ch*) name=ch;	unit=${i#ch};	chr=54;;
	uk*) name=uk;	unit=${i#uk};	chr=55;;
	esac
	rm -f $name$unit
	mknod $name$unit	c $chr $unit
	chgrp operator $name$unit
	chmod 640 $name$unit
	;;

ss*)
	case $i in
	ss*) name=ss;	unit=${i#ss};	chr=53;;
	esac
	rm -f $name$unit n$name$unit en$name$unit
	mknod $name$unit	c $chr $(($unit * 16 + 0))
	mknod n$name$unit	c $chr $(($unit * 16 + 1))
	mknod en$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator $name$unit n$name$unit en$name$unit
	chmod 640 $name$unit n$name$unit en$name$unit
	;;

scsibus*)
	unit=${i#scsibus}
	rm -f scsibus$unit
	mknod scsibus$unit c 95 $unit
	chmod 644 scsibus$unit
	;;

clockctl)
	rm -f clockctl
	mknod clockctl c 100 0
	chgrp ntpd clockctl
	chmod 660 clockctl
	;;

local)
	if [ -f "$0.local" ]; then
		umask 0
		sh $0.local all
		umask 77
	fi
	;;

*)
	echo $i: unknown device
	;;

esac
done

}

makedev $*
