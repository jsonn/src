.\"	$NetBSD: BIO_new_bio_pair.3,v 1.6.2.2 2002/08/29 16:46:17 he Exp $
.\"
.\" Automatically generated by Pod::Man version 1.02
.\" Sat Aug 10 00:55:48 2002
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "BIO_new_bio_pair 3"
.TH BIO_new_bio_pair 3 "0.9.6g" "2001-04-12" "OpenSSL"
.UC
.SH "NAME"
BIO_new_bio_pair \- create a new \s-1BIO\s0 pair
.SH "LIBRARY"
libcrypto, -lcrypto
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
.Ve
.Vb 1
\& int BIO_new_bio_pair(BIO **bio1, size_t writebuf1, BIO **bio2, size_t writebuf2);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIBIO_new_bio_pair()\fR creates a buffering \s-1BIO\s0 pair. It has two endpoints between
data can be buffered. Its typical use is to connect one endpoint as underlying
input/output \s-1BIO\s0 to an \s-1SSL\s0 and access the other one controlled by the program
instead of accessing the network connection directly.
.PP
The two new BIOs \fBbio1\fR and \fBbio2\fR are symmetric with respect to their
functionality. The size of their buffers is determined by \fBwritebuf1\fR and
\&\fBwritebuf2\fR. If the size give is 0, the default size is used.
.PP
\&\fIBIO_new_bio_pair()\fR does not check whether \fBbio1\fR or \fBbio2\fR do point to
some other \s-1BIO\s0, the values are overwritten, \fIBIO_free()\fR is not called.
.PP
The two BIOs, even though forming a \s-1BIO\s0 pair and must be \fIBIO_free()\fR'ed
separately. This can be of importance, as some SSL-functions like \fISSL_set_bio()\fR
or \fISSL_free()\fR call \fIBIO_free()\fR implicitly, so that the peer-BIO is left
untouched and must also be \fIBIO_free()\fR'ed.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
The \s-1BIO\s0 pair can be used to have full control over the network access of an
application. The application can call \fIselect()\fR on the socket as required
without having to go through the SSL-interface.
.PP
.Vb 6
\& BIO *internal_bio, *network_bio;
\& ...
\& BIO_new_bio_pair(internal_bio, 0, network_bio, 0);
\& SSL_set_bio(ssl, internal_bio);
\& SSL_operations();
\& ...
.Ve
.Vb 9
\& application |   TLS-engine
\&    |        |
\&    +----------> SSL_operations()
\&             |     /\e    ||
\&             |     ||    \e/
\&             |   BIO-pair (internal_bio)
\&    +----------< BIO-pair (network_bio)
\&    |        |
\&  socket     |
.Ve
.Vb 4
\&  ...
\&  SSL_free(ssl);                /* implicitly frees internal_bio */
\&  BIO_free(network_bio);
\&  ...
.Ve
As the \s-1BIO\s0 pair will only buffer the data and never directly access the
connection, it behaves non-blocking and will return as soon as the write
buffer is full or the read buffer is drained. Then the application has to
flush the write buffer and/or fill the read buffer.
.PP
Use the \fIBIO_ctrl_pending()\fR, to find out whether data is buffered in the \s-1BIO\s0
and must be transfered to the network. Use \fIBIO_ctrl_get_read_request()\fR to
find out, how many bytes must be written into the buffer before the
\&\fISSL_operation()\fR can successfully be continued.
.SH "IMPORTANT"
.IX Header "IMPORTANT"
As the data is buffered, \fISSL_operation()\fR may return with a \s-1ERROR_SSL_WANT_READ\s0
condition, but there is still data in the write buffer. An application must
not rely on the error value of \fISSL_operation()\fR but must assure that the
write buffer is always flushed first. Otherwise a deadlock may occur as
the peer might be waiting for the data before being able to continue.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
The following return values can occur:
.Ip "1" 4
.IX Item "1"
The \s-1BIO\s0 pair was created successfully. The new BIOs are available in
\&\fBbio1\fR and \fBbio2\fR.
.Ip "0" 4
The operation failed. The \s-1NULL\s0 pointer is stored into the locations for
\&\fBbio1\fR and \fBbio2\fR. Check the error stack for more information.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SSL_set_bio(3), ssl(3), openssl_bio(3),
BIO_ctrl_pending(3),
BIO_ctrl_get_read_request(3)
