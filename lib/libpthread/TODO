$NetBSD: TODO,v 1.8.2.2 2007/09/03 10:14:13 skrll Exp $

Bugs to fix:

- Add locking to ld.elf_so so that multiple threads doing lazy binding
  doesn't trash things.

Interfaces/features to implement:

- Priority scheduling.

- Priority inheritance.

- Figure out whether/how to use registers reserved in the ABI for
  thread-specific-data to implement pthread_self().

- Figure out what to do with changing stack sizes.

- A race between pthread_exit() and pthread_create() for detached LWPs,
  where the stack (and pthread structure) could be reclaimed before the
  thread has a chance to call _lwp_exit(), is currently prevented by
  checking the return of _lwp_kill(target, 0).  It could be done more
  efficiently.  (See shared page item.)

- Adaptive mutexes and spinlocks (see shared page item).

- Have a shared page that:

  o Allows an LWP to request it not be preempted by the kernel. This would
    be used over critical sections like pthread_cond_wait(), where we can
    acquire a bunch of spin locks: being preempted while holding them would
    suck. _lwp_park() would reset the flag once in kernel mode, and there
    would need to be an equivalent way to do this from user mode. The user
    path would probably need to notice deferred preemption and call
    sched_yield() on exit from the critical section.

  o Perhaps has some kind of hint mechanism that gives us a clue about
    whether an LWP is currently running on another CPU. This could be used
    for adaptive locks, but would need to be cheap to do in-kernel.

  o Perhaps has a flag value that's reset when a detached LWP is into the
    kernel and lwp_exit1(), meaning that its stack can be reclaimed. Again,
    may or may not be worth it.

- Keep a pool of dead LWPs so that we do not have take the full hit of
  _lwp_create() every time pthread_create() is called.

- Need to give consideration to the order in which threads enter and exit
  synchronisation objects, both in the pthread library and in the kernel.
  Commonly locks are acquired/released in order (a, b, c -> c, b, a).
