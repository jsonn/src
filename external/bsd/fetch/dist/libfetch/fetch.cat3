FETCH(3)                NetBSD Library Functions Manual               FETCH(3)

NNAAMMEE
     ffeettcchhMMaakkeeUURRLL, ffeettcchhPPaarrsseeUURRLL, ffeettcchhCCooppyyUURRLL, ffeettcchhFFrreeeeUURRLL, ffeettcchhXXGGeettUURRLL,
     ffeettcchhGGeettUURRLL, ffeettcchhPPuuttUURRLL, ffeettcchhSSttaattUURRLL, ffeettcchhLLiissttUURRLL, ffeettcchhXXGGeett,
     ffeettcchhGGeett, ffeettcchhPPuutt, ffeettcchhSSttaatt, ffeettcchhLLiisstt, ffeettcchhXXGGeettFFiillee, ffeettcchhGGeettFFiillee,
     ffeettcchhPPuuttFFiillee, ffeettcchhSSttaattFFiillee, ffeettcchhLLiissttFFiillee, ffeettcchhXXGGeettHHTTTTPP, ffeettcchhGGeettHHTTTTPP,
     ffeettcchhPPuuttHHTTTTPP, ffeettcchhSSttaattHHTTTTPP, ffeettcchhLLiissttHHTTTTPP, ffeettcchhXXGGeettFFTTPP, ffeettcchhGGeettFFTTPP,
     ffeettcchhPPuuttFFTTPP, ffeettcchhSSttaattFFTTPP, ffeettcchhLLiissttFFTTPP ffeettcchhIInniittUURRLLLLiisstt,
     ffeettcchhFFrreeeeUURRLLLLiisstt, ffeettcchhUUnnqquuootteePPaatthh, ffeettcchhUUnnqquuootteeFFiilleennaammee,
     ffeettcchhSSttrriinnggiiffyyUURRLL, ffeettcchh -- file transfer functions

LLIIBBRRAARRYY
     library ``libfetch''

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssttddiioo..hh>>
     ##iinncclluuddee <<ffeettcchh..hh>>

     _s_t_r_u_c_t _u_r_l _*
     ffeettcchhMMaakkeeUURRLL(_c_o_n_s_t _c_h_a_r _*_s_c_h_e_m_e, _c_o_n_s_t _c_h_a_r _*_h_o_s_t, _i_n_t _p_o_r_t,
         _c_o_n_s_t _c_h_a_r _*_d_o_c, _c_o_n_s_t _c_h_a_r _*_u_s_e_r, _c_o_n_s_t _c_h_a_r _*_p_w_d);

     _s_t_r_u_c_t _u_r_l _*
     ffeettcchhPPaarrsseeUURRLL(_c_o_n_s_t _c_h_a_r _*_U_R_L);

     _s_t_r_u_c_t _u_r_l _*
     ffeettcchhCCooppyyUURRLL(_c_o_n_s_t _s_t_r_u_c_t _u_r_l _*_u);

     _v_o_i_d
     ffeettcchhFFrreeeeUURRLL(_s_t_r_u_c_t _u_r_l _*_u);

     _f_e_t_c_h_I_O _*
     ffeettcchhXXGGeettUURRLL(_c_o_n_s_t _c_h_a_r _*_U_R_L, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhGGeettUURRLL(_c_o_n_s_t _c_h_a_r _*_U_R_L, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhPPuuttUURRLL(_c_o_n_s_t _c_h_a_r _*_U_R_L, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhSSttaattUURRLL(_c_o_n_s_t _c_h_a_r _*_U_R_L, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhLLiissttUURRLL(_s_t_r_u_c_t _u_r_l___l_i_s_t _*_l_i_s_t, _c_o_n_s_t _c_h_a_r _*_U_R_L, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhXXGGeett(_s_t_r_u_c_t _u_r_l _*_u, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhGGeett(_s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhPPuutt(_s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhSSttaatt(_s_t_r_u_c_t _u_r_l _*_u, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhLLiisstt(_s_t_r_u_c_t _u_r_l___l_i_s_t _*_l_i_s_t, _s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhXXGGeettFFiillee(_s_t_r_u_c_t _u_r_l _*_u, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhGGeettFFiillee(_s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhPPuuttFFiillee(_s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhSSttaattFFiillee(_s_t_r_u_c_t _u_r_l _*_u, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhLLiissttFFiillee(_s_t_r_u_c_t _u_r_l___l_i_s_t _*_l_i_s_t, _s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhXXGGeettHHTTTTPP(_s_t_r_u_c_t _u_r_l _*_u, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhGGeettHHTTTTPP(_s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhPPuuttHHTTTTPP(_s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhSSttaattHHTTTTPP(_s_t_r_u_c_t _u_r_l _*_u, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhLLiissttHHTTTTPP(_s_t_r_u_c_t _u_r_l___l_i_s_t _*_l_i_s_t, _s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhXXGGeettFFTTPP(_s_t_r_u_c_t _u_r_l _*_u, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhGGeettFFTTPP(_s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _f_e_t_c_h_I_O _*
     ffeettcchhPPuuttFFTTPP(_s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhSSttaattFFTTPP(_s_t_r_u_c_t _u_r_l _*_u, _s_t_r_u_c_t _u_r_l___s_t_a_t _*_u_s, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _i_n_t
     ffeettcchhLLiissttFFTTPP(_s_t_r_u_c_t _u_r_l___l_i_s_t _*_l_i_s_t, _s_t_r_u_c_t _u_r_l _*_u, _c_o_n_s_t _c_h_a_r _*_f_l_a_g_s);

     _v_o_i_d
     ffeettcchhIInniittUURRLLLLiisstt(_s_t_r_u_c_t _u_r_l___l_i_s_t _*_u_l);

     _v_o_i_d
     ffeettcchhFFrreeeeUURRLLLLiisstt(_s_t_r_u_c_t _u_r_l___l_i_s_t _*_u_l);

     _c_h_a_r _*
     ffeettcchhUUnnqquuootteePPaatthh(_s_t_r_u_c_t _u_r_l _*_u);

     _c_h_a_r _*
     ffeettcchhUUnnqquuootteeFFiilleennaammee(_s_t_r_u_c_t _u_r_l _*_u);

     _c_h_a_r _*
     ffeettcchhSSttrriinnggiiffyyUURRLL(_c_o_n_s_t _s_t_r_u_c_t _u_r_l _*_u);

DDEESSCCRRIIPPTTIIOONN
     These functions implement a high-level library for retrieving and upload-
     ing files using Uniform Resource Locators (URLs).

     ffeettcchhPPaarrsseeUURRLL() takes a URL in the form of a null-terminated string and
     splits it into its components function according to the Common Internet
     Scheme Syntax detailed in RFC1738.  A regular expression which produces
     this syntax is:

         <scheme>:(//(<user>(:<pwd>)?@)?<host>(:<port>)?)?/(<document>)?

     If the URL does not seem to begin with a scheme name, it is assumed to be
     a local path.  Only absolute path names are accepted.

     Note that some components of the URL are not necessarily relevant to all
     URL schemes.  For instance, the file scheme only needs the <scheme> and
     <document> components.  ffeettcchhPPaarrsseeUURRLL() quotes any unsafe character in
     the URL automatically.  This is not done by ffeettcchhMMaakkeeUURRLL().
     ffeettcchhCCooppyyUURRLL() copies an existing _u_r_l structure.

     ffeettcchhMMaakkeeUURRLL(), ffeettcchhPPaarrsseeUURRLL() and ffeettcchhCCooppyyUURRLL() return a pointer to a
     _u_r_l structure, which is defined as follows in <_f_e_t_c_h_._h>:

     #define URL_SCHEMELEN 16
     #define URL_USERLEN 256
     #define URL_PWDLEN 256
     #define URL_HOSTLEN 255

     struct url {
         char         scheme[URL_SCHEMELEN + 1];
         char         user[URL_USERLEN + 1];
         char         pwd[URL_PWDLEN + 1];
         char         host[URL_HOSTLEN + 1];
         int          port;
         char        *doc;
         off_t        offset;
         size_t       length;
     };

     The pointer returned by ffeettcchhMMaakkeeUURRLL(), ffeettcchhCCooppyyUURRLL() and
     ffeettcchhPPaarrsseeUURRLL() should be freed using ffeettcchhFFrreeeeUURRLL().

     ffeettcchhXXGGeettUURRLL(), ffeettcchhGGeettUURRLL(), and ffeettcchhPPuuttUURRLL() constitute the recom-
     mended interface to the ffeettcchh library.  They examine the URL passed to
     them to determine the transfer method, and call the appropriate lower-
     level functions to perform the actual transfer.  ffeettcchhXXGGeettUURRLL() also
     returns the remote document's metadata in the _u_r_l___s_t_a_t structure pointed
     to by the _u_s argument.

     The _f_l_a_g_s argument is a string of characters which specify transfer
     options.  The meaning of the individual flags is scheme-dependent, and is
     detailed in the appropriate section below.

     ffeettcchhSSttaattUURRLL() attempts to obtain the requested document's metadata and
     fill in the structure pointed to by its second argument.  The _u_r_l___s_t_a_t
     structure is defined as follows in <_f_e_t_c_h_._h>:

     struct url_stat {
         off_t        size;
         time_t       atime;
         time_t       mtime;
     };

     If the size could not be obtained from the server, the _s_i_z_e field is set
     to -1.  If the modification time could not be obtained from the server,
     the _m_t_i_m_e field is set to the epoch.  If the access time could not be
     obtained from the server, the _a_t_i_m_e field is set to the modification
     time.

     ffeettcchhLLiissttUURRLL() attempts to list the contents of the directory pointed to
     by the URL provided.  The pattern can be a simple glob-like expression as
     hint.  Callers should not depend on the server to filter names.  If suc-
     cessful, it appends the list of entries to the _u_r_l___l_i_s_t structure.  The
     _u_r_l___l_i_s_t structure is defined as follows in <_f_e_t_c_h_._h>:

     struct url_list {
         size_t      length;
         size_t      alloc_size;
         struct url  *urls;
     };

     The list should be initialised by calling ffeettcchhIInniittUURRLLLLiisstt() and the
     entries be freed by calling ffeettcchhFFrreeeeUURRLLLLiisstt().

     ffeettcchhSSttrriinnggiiffyyUURRLL() returns the URL as string.  ffeettcchhUUnnqquuootteePPaatthh()
     returns the path name part of the URL with any quoting undone.  Query
     arguments and fragment identifiers are not included.
     ffeettcchhUUnnqquuootteeFFiilleennaammee() returns the last component of the path name as
     returned by ffeettcchhUUnnqquuootteePPaatthh().  ffeettcchhSSttrriinnggiiffyyUURRLL(), ffeettcchhUUnnqquuootteePPaatthh()
     and ffeettcchhUUnnqquuootteeFFiilleennaammee() return a string that should be deallocated
     with ffrreeee() after use.

     ffeettcchhXXGGeett(), ffeettcchhGGeett(), ffeettcchhPPuutt() and ffeettcchhSSttaatt() are similar to
     ffeettcchhXXGGeettUURRLL(), ffeettcchhGGeettUURRLL(), ffeettcchhPPuuttUURRLL() and ffeettcchhSSttaattUURRLL(), except
     that they expect a pre-parsed URL in the form of a pointer to a _s_t_r_u_c_t
     _u_r_l rather than a string.

     All of the ffeettcchhXXGGeettXXXXXX(), ffeettcchhGGeettXXXXXX() and ffeettcchhPPuuttXXXXXX() functions
     return a pointer to a stream which can be used to read or write data from
     or to the requested document, respectively.  Note that although the
     implementation details of the individual access methods vary, it can gen-
     erally be assumed that a stream returned by one of the ffeettcchhXXGGeettXXXXXX() or
     ffeettcchhGGeettXXXXXX() functions is read-only, and that a stream returned by one
     of the ffeettcchhPPuuttXXXXXX() functions is write-only.

FFIILLEE SSCCHHEEMMEE
     ffeettcchhXXGGeettFFiillee(), ffeettcchhGGeettFFiillee() and ffeettcchhPPuuttFFiillee() provide access to doc-
     uments which are files in a locally mounted file system.  Only the <docu-
     ment> component of the URL is used.

     ffeettcchhXXGGeettFFiillee() and ffeettcchhGGeettFFiillee() do not accept any flags.

     ffeettcchhPPuuttFFiillee() accepts the `a' (append to file) flag.  If that flag is
     specified, the data written to the stream returned by ffeettcchhPPuuttFFiillee() will
     be appended to the previous contents of the file, instead of replacing
     them.

FFTTPP SSCCHHEEMMEE
     ffeettcchhXXGGeettFFTTPP(), ffeettcchhGGeettFFTTPP() and ffeettcchhPPuuttFFTTPP() implement the FTP proto-
     col as described in RFC959.

     If the `p' (passive) flag is specified, a passive (rather than active)
     connection will be attempted.

     If the `l' (low) flag is specified, data sockets will be allocated in the
     low (or default) port range instead of the high port range (see ip(4)).

     If the `d' (direct) flag is specified, ffeettcchhXXGGeettFFTTPP(), ffeettcchhGGeettFFTTPP() and
     ffeettcchhPPuuttFFTTPP() will use a direct connection even if a proxy server is
     defined.

     If no user name or password is given, the ffeettcchh library will attempt an
     anonymous login, with user name "anonymous" and password "anony-
     mous@<hostname>".

HHTTTTPP SSCCHHEEMMEE
     The ffeettcchhXXGGeettHHTTTTPP(), ffeettcchhGGeettHHTTTTPP() and ffeettcchhPPuuttHHTTTTPP() functions imple-
     ment the HTTP/1.1 protocol.  With a little luck, there is even a chance
     that they comply with RFC2616 and RFC2617.

     If the `d' (direct) flag is specified, ffeettcchhXXGGeettHHTTTTPP(), ffeettcchhGGeettHHTTTTPP()
     and ffeettcchhPPuuttHHTTTTPP() will use a direct connection even if a proxy server is
     defined.

     Since there seems to be no good way of implementing the HTTP PUT method
     in a manner consistent with the rest of the ffeettcchh library, ffeettcchhPPuuttHHTTTTPP()
     is currently unimplemented.

AAUUTTHHEENNTTIICCAATTIIOONN
     Apart from setting the appropriate environment variables and specifying
     the user name and password in the URL or the _s_t_r_u_c_t _u_r_l, the calling pro-
     gram has the option of defining an authentication function with the fol-
     lowing prototype:

     _i_n_t mmyyAAuutthhMMeetthhoodd(_s_t_r_u_c_t _u_r_l _*_u)

     The callback function should fill in the _u_s_e_r and _p_w_d fields in the pro-
     vided _s_t_r_u_c_t _u_r_l and return 0 on success, or any other value to indicate
     failure.

     To register the authentication callback, simply set _f_e_t_c_h_A_u_t_h_M_e_t_h_o_d to
     point at it.  The callback will be used whenever a site requires authen-
     tication and the appropriate environment variables are not set.

     This interface is experimental and may be subject to change.

RREETTUURRNN VVAALLUUEESS
     ffeettcchhPPaarrsseeUURRLL() returns a pointer to a _s_t_r_u_c_t _u_r_l containing the individ-
     ual components of the URL.  If it is unable to allocate memory, or the
     URL is syntactically incorrect, ffeettcchhPPaarrsseeUURRLL() returns a NULL pointer.

     The ffeettcchhSSttaatt() functions return 0 on success and -1 on failure.

     All other functions return a stream pointer which may be used to access
     the requested document, or NULL if an error occurred.

     The following error codes are defined in <_f_e_t_c_h_._h>:

     [FETCH_ABORT]       Operation aborted

     [FETCH_AUTH]        Authentication failed

     [FETCH_DOWN]        Service unavailable

     [FETCH_EXISTS]      File exists

     [FETCH_FULL]        File system full

     [FETCH_INFO]        Informational response

     [FETCH_MEMORY]      Insufficient memory

     [FETCH_MOVED]       File has moved

     [FETCH_NETWORK]     Network error

     [FETCH_OK]          No error

     [FETCH_PROTO]       Protocol error

     [FETCH_RESOLV]      Resolver error

     [FETCH_SERVER]      Server error

     [FETCH_TEMP]        Temporary error

     [FETCH_TIMEOUT]     Operation timed out

     [FETCH_UNAVAIL]     File is not available

     [FETCH_UNKNOWN]     Unknown error

     [FETCH_URL]         Invalid URL

     The accompanying error message includes a protocol-specific error code
     and message, e.g. "File is not available (404 Not Found)"

EENNVVIIRROONNMMEENNTT
     FETCH_BIND_ADDRESS  Specifies a hostname or IP address to which sockets
                         used for outgoing connections will be bound.

     FTP_LOGIN           Default FTP login if none was provided in the URL.

     FTP_PASSIVE_MODE    If set to anything but `no', forces the FTP code to
                         use passive mode.

     FTP_PASSWORD        Default FTP password if the remote server requests
                         one and none was provided in the URL.

     FTP_PROXY           URL of the proxy to use for FTP requests.  The docu-
                         ment part is ignored.  FTP and HTTP proxies are sup-
                         ported; if no scheme is specified, FTP is assumed.
                         If the proxy is an FTP proxy, lliibbffeettcchh will send
                         `user@host' as user name to the proxy, where `user'
                         is the real user name, and `host' is the name of the
                         FTP server.

                         If this variable is set to an empty string, no proxy
                         will be used for FTP requests, even if the HTTP_PROXY
                         variable is set.

     ftp_proxy           Same as FTP_PROXY, for compatibility.

     HTTP_AUTH           Specifies HTTP authorization parameters as a colon-
                         separated list of items.  The first and second item
                         are the authorization scheme and realm respectively;
                         further items are scheme-dependent.  Currently, only
                         basic authorization is supported.

                         Basic authorization requires two parameters: the user
                         name and password, in that order.

                         This variable is only used if the server requires
                         authorization and no user name or password was speci-
                         fied in the URL.

     HTTP_PROXY          URL of the proxy to use for HTTP requests.  The docu-
                         ment part is ignored.  Only HTTP proxies are sup-
                         ported for HTTP requests.  If no port number is spec-
                         ified, the default is 3128.

                         Note that this proxy will also be used for FTP docu-
                         ments, unless the FTP_PROXY variable is set.

     http_proxy          Same as HTTP_PROXY, for compatibility.

     HTTP_PROXY_AUTH     Specifies authorization parameters for the HTTP proxy
                         in the same format as the HTTP_AUTH variable.

                         This variable is used if and only if connected to an
                         HTTP proxy, and is ignored if a user and/or a pass-
                         word were specified in the proxy URL.

     HTTP_REFERER        Specifies the referrer URL to use for HTTP requests.
                         If set to ``auto'', the document URL will be used as
                         referrer URL.

     HTTP_USER_AGENT     Specifies the User-Agent string to use for HTTP
                         requests.  This can be useful when working with HTTP
                         origin or proxy servers that differentiate between
                         user agents.

     NETRC               Specifies a file to use instead of _~_/_._n_e_t_r_c to look
                         up login names and passwords for FTP sites.  See
                         ftp(1) for a description of the file format.  This
                         feature is experimental.

     NO_PROXY            Either a single asterisk, which disables the use of
                         proxies altogether, or a comma- or whitespace-sepa-
                         rated list of hosts for which proxies should not be
                         used.

     no_proxy            Same as NO_PROXY, for compatibility.

EEXXAAMMPPLLEESS
     To access a proxy server on _p_r_o_x_y_._e_x_a_m_p_l_e_._c_o_m port 8080, set the
     HTTP_PROXY environment variable in a manner similar to this:

           HTTP_PROXY=http://proxy.example.com:8080

     If the proxy server requires authentication, there are two options avail-
     able for passing the authentication data.  The first method is by using
     the proxy URL:

           HTTP_PROXY=http://<user>:<pwd>@proxy.example.com:8080

     The second method is by using the HTTP_PROXY_AUTH environment variable:

           HTTP_PROXY=http://proxy.example.com:8080
           HTTP_PROXY_AUTH=basic:*:<user>:<pwd>

     To disable the use of a proxy for an HTTP server running on the local
     host, define NO_PROXY as follows:

           NO_PROXY=localhost,127.0.0.1

SSEEEE AALLSSOO
     fetch(1), ftpio(3), ip(4)

     J. Postel and J. K. Reynolds, _F_i_l_e _T_r_a_n_s_f_e_r _P_r_o_t_o_c_o_l, October 1985,
     RFC959.

     P. Deutsch, A. Emtage, and A. Marine., _H_o_w _t_o _U_s_e _A_n_o_n_y_m_o_u_s _F_T_P, May
     1994, RFC1635.

     T. Berners-Lee, L. Masinter, and M. McCahill, _U_n_i_f_o_r_m _R_e_s_o_u_r_c_e _L_o_c_a_t_o_r_s
     _(_U_R_L_), December 1994, RFC1738.

     R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, P. Leach, and
     T. Berners-Lee, _H_y_p_e_r_t_e_x_t _T_r_a_n_s_f_e_r _P_r_o_t_o_c_o_l _-_- _H_T_T_P_/_1_._1, January 1999,
     RFC2616.

     J. Franks, P. Hallam-Baker, J. Hostetler, S. Lawrence, P. Leach, A.
     Luotonen, and L. Stewart, _H_T_T_P _A_u_t_h_e_n_t_i_c_a_t_i_o_n_: _B_a_s_i_c _a_n_d _D_i_g_e_s_t _A_c_c_e_s_s
     _A_u_t_h_e_n_t_i_c_a_t_i_o_n, June 1999, RFC2617.

HHIISSTTOORRYY
     The ffeettcchh library first appeared in FreeBSD 3.0.

AAUUTTHHOORRSS
     The ffeettcchh library was mostly written by Dag-Erling Sm/orgrav
     <des@FreeBSD.org> with numerous suggestions from Jordan K. Hubbard
     <jkh@FreeBSD.org>, Eugene Skepner <eu@qub.com> and other FreeBSD develop-
     ers.  It replaces the older ffttppiioo library written by Poul-Henning Kamp
     <phk@FreeBSD.org> and Jordan K. Hubbard <jkh@FreeBSD.org>.

     This manual page was written by Dag-Erling Sm/orgrav <des@FreeBSD.org>.

BBUUGGSS
     Some parts of the library are not yet implemented.  The most notable
     examples of this are ffeettcchhPPuuttHHTTTTPP() and FTP proxy support.

     There is no way to select a proxy at run-time other than setting the
     HTTP_PROXY or FTP_PROXY environment variables as appropriate.

     lliibbffeettcchh does not understand or obey 305 (Use Proxy) replies.

     Error numbers are unique only within a certain context; the error codes
     used for FTP and HTTP overlap, as do those used for resolver and system
     errors.  For instance, error code 202 means "Command not implemented,
     superfluous at this site" in an FTP context and "Accepted" in an HTTP
     context.

     ffeettcchhSSttaattFFTTPP() does not check that the result of an MDTM command is a
     valid date.

     The man page is incomplete, poorly written and produces badly formatted
     text.

     The error reporting mechanism is unsatisfactory.

     Some parts of the code are not fully reentrant.

NetBSD 4.0                      April 25, 2008                      NetBSD 4.0
