#!/bin/sh
##
##  GNU shtool -- The GNU Portable Shell Tool
##  Copyright (c) 1994-2006 Ralf S. Engelschall <rse@engelschall.com>
##
##  See http://www.gnu.org/software/shtool/ for more information.
##  See ftp://ftp.gnu.org/gnu/shtool/ for latest version.
##
##  Version:  2.0.5 (07-Feb-2006)
##  Contents: 6/19 available modules
##

##
##  This program is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 2 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
##  General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program; if not, write to the Free Software
##  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
##  USA, or contact Ralf S. Engelschall <rse@engelschall.com>.
##
##  NOTICE: Given that you include this file verbatim into your own
##  source tree, you are justified in saying that it remains separate
##  from your package, and that this way you are simply just using GNU
##  shtool. So, in this situation, there is no requirement that your
##  package itself is licensed under the GNU General Public License in
##  order to take advantage of GNU shtool.
##

##
##  Usage: shtool [<options>] [<cmd-name> [<cmd-options>] [<cmd-args>]]
##
##  Available commands:
##    echo       Print string with optional construct expansion
##    move       Move files with simultaneous substitution
##    install    Install a program, script or datafile
##    mkdir      Make one or more directories
##    mkln       Make link with calculation of relative paths
##    subst      Apply sed(1) substitution operations
##
##  Not available commands (because module was not built-in):
##    mdate      Pretty-print modification time of a file or dir
##    table      Pretty-print a field-separated list as a table
##    prop       Display progress with a running propeller
##    mkshadow   Make a shadow tree through symbolic links
##    fixperm    Fix file permissions inside a source tree
##    rotate     Logfile rotation
##    tarball    Roll distribution tarballs
##    platform   Platform Identification Utility
##    arx        Extended archive command
##    slo        Separate linker options by library class
##    scpp       Sharing C Pre-Processor
##    version    Maintain a version information file
##    path       Deal with program paths
##

#   maximum Bourne-Shell compatibility
if [ ".$ZSH_VERSION" != . ] && (emulate sh) >/dev/null 2>&1; then
    #   reconfigure zsh(1)
    emulate sh
    NULLCMD=:
    alias -g '${1+"$@"}'='"$@"'
elif [ ".$BASH_VERSION" != . ] && (set -o posix) >/dev/null 2>&1; then
    #   reconfigure bash(1)
    set -o posix
fi

#   maximum independence of NLS nuisances
for var in \
    LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
    LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
    LC_TELEPHONE LC_TIME
do
    if (set +x; test -z "`(eval $var=C; export $var) 2>&1`"); then
        eval $var=C; export $var
    else
        unset $var
    fi
done

#   initial command line handling
if [ $# -eq 0 ]; then
    echo "$0:Error: invalid command line" 1>&2
    echo "$0:Hint:  run \`$0 -h' for usage" 1>&2
    exit 1
fi
if [ ".$1" = ".-h" ] || [ ".$1" = ".--help" ]; then
    echo "This is GNU shtool, version 2.0.5 (07-Feb-2006)"
    echo 'Copyright (c) 1994-2006 Ralf S. Engelschall <rse@engelschall.com>'
    echo 'Report bugs to <bug-shtool@gnu.org>'
    echo ''
    echo 'Usage: shtool [<options>] [<cmd-name> [<cmd-options>] [<cmd-args>]]'
    echo ''
    echo 'Available global <options>:'
    echo '  -v, --version   display shtool version information'
    echo '  -h, --help      display shtool usage help page (this one)'
    echo '  -d, --debug     display shell trace information'
    echo '  -r, --recreate  recreate this shtool script via shtoolize'
    echo ''
    echo 'Available <cmd-name> [<cmd-options>] [<cmd-args>]:'
    echo '  echo     [-n|--newline] [-e|--expand] [<string> ...]'
    echo '  move     [-v|--verbose] [-t|--trace] [-e|--expand] [-p|--preserve]'
    echo '           <src-file> <dst-file>'
    echo '  install  [-v|--verbose] [-t|--trace] [-d|--mkdir] [-c|--copy]'
    echo '           [-C|--compare-copy] [-s|--strip] [-m|--mode <mode>]'
    echo '           [-o|--owner <owner>] [-g|--group <group>] [-e|--exec'
    echo '           <sed-cmd>] <file> [<file> ...] <path>'
    echo '  mkdir    [-t|--trace] [-f|--force] [-p|--parents] [-m|--mode'
    echo '           <mode>] [-o|--owner <owner>] [-g|--group <group>] <dir>'
    echo '           [<dir> ...]'
    echo '  mkln     [-t|--trace] [-f|--force] [-s|--symbolic] <src-path>'
    echo '           [<src-path> ...] <dst-path>'
    echo '  subst    [-v|--verbose] [-t|--trace] [-n|--nop] [-w|--warning]'
    echo '           [-q|--quiet] [-s|--stealth] [-i|--interactive] [-b|--backup'
    echo '           <ext>] [-e|--exec <cmd>] [-f|--file <cmd-file>] [<file>]'
    echo '           [...]'
    echo ''
    echo 'Not available <cmd-name> (because module was not built-in):'
    echo '  mdate    [-n|--newline] [-z|--zero] [-s|--shorten] [-d|--digits]'
    echo '           [-f|--field-sep <str>] [-o|--order <spec>] <path>'
    echo '  table    [-F|--field-sep <sep>] [-w|--width <width>] [-c|--columns'
    echo '           <cols>] [-s|--strip <strip>] <str><sep><str>...'
    echo '  prop     [-p|--prefix <str>]'
    echo '  mkshadow [-v|--verbose] [-t|--trace] [-a|--all] <src-dir> <dst-dir>'
    echo '  fixperm  [-v|--verbose] [-t|--trace] <path> [<path> ...]'
    echo '  rotate   [-v|--verbose] [-t|--trace] [-f|--force] [-n|--num-files'
    echo '           <count>] [-s|--size <size>] [-c|--copy] [-r|--remove]'
    echo '           [-a|--archive-dir <dir>] [-z|--compress [<tool>:]<level>]'
    echo '           [-b|--background] [-d|--delay] [-p|--pad <len>] [-m|--mode'
    echo '           <mode>] [-o|--owner <owner>] [-g|--group <group>] [-M|--migrate'
    echo '           <cmd>] [-P|--prolog <cmd>] [-E|--epilog <cmd>] <file> [...]'
    echo '  tarball  [-t|--trace] [-v|--verbose] [-o|--output <tarball>]'
    echo '           [-c|--compress <prog>] [-d|--directory <dir>] [-u|--user'
    echo '           <user>] [-g|--group <group>] [-e|--exclude <pattern>]'
    echo '           <path> [<path> ...]'
    echo '  platform [-F|--format <format>] [-S|--sep <string>] [-C|--conc'
    echo '           <string>] [-L|--lower] [-U|--upper] [-v|--verbose]'
    echo '           [-c|--concise] [-n|--no-newline] [-t|--type <type>]'
    echo '           [-V|--version] [-h|--help]'
    echo '  arx      [-t|--trace] [-C|--command <cmd>] <op> <archive> [<file>'
    echo '           ...]'
    echo '  slo      [-p|--prefix <str>] -- -L<dir> -l<lib> [-L<dir> -l<lib>'
    echo '           ...]'
    echo '  scpp     [-v|--verbose] [-p|--preserve] [-f|--filter <filter>]'
    echo '           [-o|--output <ofile>] [-t|--template <tfile>] [-M|--mark'
    echo '           <mark>] [-D|--define <dname>] [-C|--class <cname>]'
    echo '           <file> [<file> ...]'
    echo '  version  [-l|--language <lang>] [-n|--name <name>] [-p|--prefix'
    echo '           <prefix>] [-s|--set <version>] [-e|--edit] [-i|--increase'
    echo '           <knob>] [-d|--display <type>] <file>'
    echo '  path     [-s|--suppress] [-r|--reverse] [-d|--dirname] [-b|--basename]'
    echo '           [-m|--magic] [-p|--path <path>] <str> [<str> ...]'
    echo ''
    exit 0
fi
if [ ".$1" = ".-v" ] || [ ".$1" = ".--version" ]; then
    echo "GNU shtool 2.0.5 (07-Feb-2006)"
    exit 0
fi
if [ ".$1" = ".-r" ] || [ ".$1" = ".--recreate" ]; then
    shtoolize -oshtool echo move install mkdir mkln subst
    exit 0
fi
if [ ".$1" = ".-d" ] || [ ".$1" = ".--debug" ]; then
    shift
    set -x
fi
name=`echo "$0" | sed -e 's;.*/\([^/]*\)$;\1;' -e 's;-sh$;;' -e 's;\.sh$;;'`
case "$name" in
    echo|move|install|mkdir|mkln|subst )
        #   implicit tool command selection
        tool="$name"
        ;;
    * )
        #   explicit tool command selection
        tool="$1"
        shift
        ;;
esac
arg_spec=""
opt_spec=""
gen_tmpfile=no

##
##  DISPATCH INTO SCRIPT PROLOG
##

case $tool in
    echo )
        str_tool="echo"
        str_usage="[-n|--newline] [-e|--expand] [<string> ...]"
        arg_spec="0+"
        opt_spec="n.e."
        opt_alias="n:newline,e:expand"
        opt_n=no
        opt_e=no
        ;;
    move )
        str_tool="move"
        str_usage="[-v|--verbose] [-t|--trace] [-e|--expand] [-p|--preserve] <src-file> <dst-file>"
        arg_spec="2="
        opt_spec="v.t.e.p."
        opt_alias="v:verbose,t:trace,e:expand,p:preserve"
        opt_v=no
        opt_t=no
        opt_e=no
        opt_p=no
        ;;
    install )
        str_tool="install"
        str_usage="[-v|--verbose] [-t|--trace] [-d|--mkdir] [-c|--copy] [-C|--compare-copy] [-s|--strip] [-m|--mode <mode>] [-o|--owner <owner>] [-g|--group <group>] [-e|--exec <sed-cmd>] <file> [<file> ...] <path>"
        arg_spec="1+"
        opt_spec="v.t.d.c.C.s.m:o:g:e+"
        opt_alias="v:verbose,t:trace,d:mkdir,c:copy,C:compare-copy,s:strip,m:mode,o:owner,g:group,e:exec"
        opt_v=no
        opt_t=no
        opt_d=no
        opt_c=no
        opt_C=no
        opt_s=no
        opt_m="0755"
        opt_o=""
        opt_g=""
        opt_e=""
        ;;
    mkdir )
        str_tool="mkdir"
        str_usage="[-t|--trace] [-f|--force] [-p|--parents] [-m|--mode <mode>] [-o|--owner <owner>] [-g|--group <group>] <dir> [<dir> ...]"
        arg_spec="1+"
        opt_spec="t.f.p.m:o:g:"
        opt_alias="t:trace,f:force,p:parents,m:mode,o:owner,g:group"
        opt_t=no
        opt_f=no
        opt_p=no
        opt_m=""
        opt_o=""
        opt_g=""
        ;;
    mkln )
        str_tool="mkln"
        str_usage="[-t|--trace] [-f|--force] [-s|--symbolic] <src-path> [<src-path> ...] <dst-path>"
        arg_spec="2+"
        opt_spec="t.f.s."
        opt_alias="t:trace,f:force,s:symbolic"
        opt_t=no
        opt_f=no
        opt_s=no
        ;;
    subst )
        str_tool="subst"
        str_usage="[-v|--verbose] [-t|--trace] [-n|--nop] [-w|--warning] [-q|--quiet] [-s|--stealth] [-i|--interactive] [-b|--backup <ext>] [-e|--exec <cmd>] [-f|--file <cmd-file>] [<file>] [...]"
        gen_tmpfile=yes
        arg_spec="0+"
        opt_spec="v.t.n.w.q.s.i.b:e+f:"
        opt_alias="v:verbose,t:trace,n:nop,w:warning,q:quiet,s:stealth,i:interactive,b:backup,e:exec,f:file"
        opt_v=no
        opt_t=no
        opt_n=no
        opt_w=no
        opt_q=no
        opt_s=no
        opt_i=no
        opt_b=""
        opt_e=""
        opt_f=""
        ;;
    -* )
        echo "$0:Error: unknown option \`$tool'" 2>&1
        echo "$0:Hint:  run \`$0 -h' for usage" 2>&1
        exit 1
        ;;
    * )
        echo "$0:Error: unknown command \`$tool'" 2>&1
        echo "$0:Hint:  run \`$0 -h' for usage" 2>&1
        exit 1
        ;;
esac

##
##  COMMON UTILITY CODE
##

#   commonly used ASCII values
ASC_TAB="	"
ASC_NL="
"

#   determine name of tool
if [ ".$tool" != . ]; then
    #   used inside shtool script
    toolcmd="$0 $tool"
    toolcmdhelp="shtool $tool"
    msgprefix="shtool:$tool"
else
    #   used as standalone script
    toolcmd="$0"
    toolcmdhelp="sh $0"
    msgprefix="$str_tool"
fi

#   parse argument specification string
eval `echo $arg_spec |\
      sed -e 's/^\([0-9]*\)\([+=]\)/arg_NUMS=\1; arg_MODE=\2/'`

#   parse option specification string
eval `echo h.$opt_spec |\
      sed -e 's/\([a-zA-Z0-9]\)\([.:+]\)/opt_MODE_\1=\2;/g'`

#   parse option alias string
eval `echo h:help,$opt_alias |\
      sed -e 's/-/_/g' -e 's/\([a-zA-Z0-9]\):\([^,]*\),*/opt_ALIAS_\2=\1;/g'`

#   interate over argument line
opt_PREV=''
while [ $# -gt 0 ]; do
    #   special option stops processing
    if [ ".$1" = ".--" ]; then
        shift
        break
    fi

    #   determine option and argument
    opt_ARG_OK=no
    if [ ".$opt_PREV" != . ]; then
        #   merge previous seen option with argument
        opt_OPT="$opt_PREV"
        opt_ARG="$1"
        opt_ARG_OK=yes
        opt_PREV=''
    else
        #   split argument into option and argument
        case "$1" in
            --[a-zA-Z0-9]*=*)
                eval `echo "x$1" |\
                      sed -e 's/^x--\([a-zA-Z0-9-]*\)=\(.*\)$/opt_OPT="\1";opt_ARG="\2"/'`
                opt_STR=`echo $opt_OPT | sed -e 's/-/_/g'`
                eval "opt_OPT=\${opt_ALIAS_${opt_STR}-${opt_OPT}}"
                ;;
            --[a-zA-Z0-9]*)
                opt_OPT=`echo "x$1" | cut -c4-`
                opt_STR=`echo $opt_OPT | sed -e 's/-/_/g'`
                eval "opt_OPT=\${opt_ALIAS_${opt_STR}-${opt_OPT}}"
                opt_ARG=''
                ;;
            -[a-zA-Z0-9]*)
                eval `echo "x$1" |\
                      sed -e 's/^x-\([a-zA-Z0-9]\)/opt_OPT="\1";/' \
                          -e 's/";\(.*\)$/"; opt_ARG="\1"/'`
                ;;
            -[a-zA-Z0-9])
                opt_OPT=`echo "x$1" | cut -c3-`
                opt_ARG=''
                ;;
            *)
                break
                ;;
        esac
    fi

    #   eat up option
    shift

    #   determine whether option needs an argument
    eval "opt_MODE=\$opt_MODE_${opt_OPT}"
    if [ ".$opt_ARG" = . ] && [ ".$opt_ARG_OK" != .yes ]; then
        if [ ".$opt_MODE" = ".:" ] || [ ".$opt_MODE" = ".+" ]; then
            opt_PREV="$opt_OPT"
            continue
        fi
    fi

    #   process option
    case $opt_MODE in
        '.' )
            #   boolean option
            eval "opt_${opt_OPT}=yes"
            ;;
        ':' )
            #   option with argument (multiple occurances override)
            eval "opt_${opt_OPT}=\"\$opt_ARG\""
            ;;
        '+' )
            #   option with argument (multiple occurances append)
            eval "opt_${opt_OPT}=\"\$opt_${opt_OPT}\${ASC_NL}\$opt_ARG\""
            ;;
        * )
            echo "$msgprefix:Error: unknown option: \`$opt_OPT'" 1>&2
            echo "$msgprefix:Hint:  run \`$toolcmdhelp -h' or \`man shtool' for details" 1>&2
            exit 1
            ;;
    esac
done
if [ ".$opt_PREV" != . ]; then
    echo "$msgprefix:Error: missing argument to option \`$opt_PREV'" 1>&2
    echo "$msgprefix:Hint:  run \`$toolcmdhelp -h' or \`man shtool' for details" 1>&2
    exit 1
fi

#   process help option
if [ ".$opt_h" = .yes ]; then
    echo "Usage: $toolcmdhelp $str_usage"
    exit 0
fi

#   complain about incorrect number of arguments
case $arg_MODE in
    '=' )
        if [ $# -ne $arg_NUMS ]; then
            echo "$msgprefix:Error: invalid number of arguments (exactly $arg_NUMS expected)" 1>&2
            echo "$msgprefix:Hint:  run \`$toolcmd -h' or \`man shtool' for details" 1>&2
            exit 1
        fi
        ;;
    '+' )
        if [ $# -lt $arg_NUMS ]; then
            echo "$msgprefix:Error: invalid number of arguments (at least $arg_NUMS expected)" 1>&2
            echo "$msgprefix:Hint:  run \`$toolcmd -h' or \`man shtool' for details" 1>&2
            exit 1
        fi
        ;;
esac

#   establish a temporary file on request
if [ ".$gen_tmpfile" = .yes ]; then
    #   create (explicitly) secure temporary directory
    if [ ".$TMPDIR" != . ]; then
        tmpdir="$TMPDIR"
    elif [ ".$TEMPDIR" != . ]; then
        tmpdir="$TEMPDIR"
    else
        tmpdir="/tmp"
    fi
    tmpdir="$tmpdir/.shtool.$$"
    ( umask 077
      rm -rf "$tmpdir" >/dev/null 2>&1 || true
      mkdir  "$tmpdir" >/dev/null 2>&1
      if [ $? -ne 0 ]; then
          echo "$msgprefix:Error: failed to create temporary directory \`$tmpdir'" 1>&2
          exit 1
      fi
    )

    #   create (implicitly) secure temporary file
    tmpfile="$tmpdir/shtool.tmp"
    touch "$tmpfile"
fi

#   utility function: map string to lower case
util_lower () {
    echo "$1" | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'
}

#   utility function: map string to upper case
util_upper () {
    echo "$1" | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
}

#   cleanup procedure
shtool_exit () {
    rc="$1"
    if [ ".$gen_tmpfile" = .yes ]; then
        rm -rf "$tmpdir" >/dev/null 2>&1 || true
    fi
    exit $rc
}

##
##  DISPATCH INTO SCRIPT BODY
##

case $tool in

echo )
    ##
    ##  echo -- Print string with optional construct expansion
    ##  Copyright (c) 1998-2006 Ralf S. Engelschall <rse@engelschall.com>
    ##

    text="$*"

    #   check for broken escape sequence expansion
    seo=''
    bytes=`echo '\1' | wc -c | awk '{ printf("%s", $1); }'`
    if [ ".$bytes" != .3 ]; then
        bytes=`echo -E '\1' | wc -c | awk '{ printf("%s", $1); }'`
        if [ ".$bytes" = .3 ]; then
            seo='-E'
        fi
    fi

    #   check for existing -n option (to suppress newline)
    minusn=''
    bytes=`echo -n 123 2>/dev/null | wc -c | awk '{ printf("%s", $1); }'`
    if [ ".$bytes" = .3 ]; then
        minusn='-n'
    fi

    #   determine terminal bold sequence
    term_bold=''
    term_norm=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%[Bb]'`" != . ]; then
        case $TERM in
            #   for the most important terminal types we directly know the sequences
            xterm|xterm*|vt220|vt220*)
                term_bold=`awk 'BEGIN { printf("%c%c%c%c", 27, 91, 49, 109); }' </dev/null 2>/dev/null`
                term_norm=`awk 'BEGIN { printf("%c%c%c", 27, 91, 109); }' </dev/null 2>/dev/null`
                ;;
            vt100|vt100*|cygwin)
                term_bold=`awk 'BEGIN { printf("%c%c%c%c%c%c", 27, 91, 49, 109, 0, 0); }' </dev/null 2>/dev/null`
                term_norm=`awk 'BEGIN { printf("%c%c%c%c%c", 27, 91, 109, 0, 0); }' </dev/null 2>/dev/null`
                ;;
            #   for all others, we try to use a possibly existing `tput' or `tcout' utility
            * )
                paths=`echo $PATH | sed -e 's/:/ /g'`
                for tool in tput tcout; do
                    for dir in $paths; do
                        if [ -r "$dir/$tool" ]; then
                            for seq in bold md smso; do # 'smso' is last
                                bold="`$dir/$tool $seq 2>/dev/null`"
                                if [ ".$bold" != . ]; then
                                    term_bold="$bold"
                                    break
                                fi
                            done
                            if [ ".$term_bold" != . ]; then
                                for seq in sgr0 me rmso init reset; do # 'reset' is last
                                    norm="`$dir/$tool $seq 2>/dev/null`"
                                    if [ ".$norm" != . ]; then
                                        term_norm="$norm"
                                        break
                                    fi
                                done
                            fi
                            break
                        fi
                    done
                    if [ ".$term_bold" != . ] && [ ".$term_norm" != . ]; then
                        break;
                    fi
                done
                ;;
        esac
        if [ ".$term_bold" = . ] || [ ".$term_norm" = . ]; then
            echo "$msgprefix:Warning: unable to determine terminal sequence for bold mode" 1>&2
            term_bold=''
            term_norm=''
        fi
    fi

    #   determine user name
    username=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%[uUgG]'`" != . ]; then
        username="`(id -un) 2>/dev/null`"
        if [ ".$username" = . ]; then
            str="`(id) 2>/dev/null`"
            if [ ".`echo $str | grep '^uid[ 	]*=[ 	]*[0-9]*('`" != . ]; then
                username=`echo $str | sed -e 's/^uid[ 	]*=[ 	]*[0-9]*(//' -e 's/).*$//'`
            fi
            if [ ".$username" = . ]; then
                username="$LOGNAME"
                if [ ".$username" = . ]; then
                    username="$USER"
                    if [ ".$username" = . ]; then
                        username="`(whoami) 2>/dev/null |\
                                   awk '{ printf("%s", $1); }'`"
                        if [ ".$username" = . ]; then
                            username="`(who am i) 2>/dev/null |\
                                       awk '{ printf("%s", $1); }'`"
                            if [ ".$username" = . ]; then
                                username='unknown'
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi

    #   determine user id
    userid=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%U'`" != . ]; then
        userid="`(id -u) 2>/dev/null`"
        if [ ".$userid" = . ]; then
            userid="`(id -u ${username}) 2>/dev/null`"
            if [ ".$userid" = . ]; then
                str="`(id) 2>/dev/null`"
                if [ ".`echo $str | grep '^uid[ 	]*=[ 	]*[0-9]*('`" != . ]; then
                    userid=`echo $str | sed -e 's/^uid[ 	]*=[ 	]*//' -e 's/(.*$//'`
                fi
                if [ ".$userid" = . ]; then
                    userid=`(getent passwd ${username}) 2>/dev/null | \
                            sed -e 's/[^:]*:[^:]*://' -e 's/:.*$//'`
                    if [ ".$userid" = . ]; then
                        userid=`grep "^${username}:" /etc/passwd 2>/dev/null | \
                                sed -e 's/[^:]*:[^:]*://' -e 's/:.*$//'`
                        if [ ".$userid" = . ]; then
                            userid=`(ypcat passwd) 2>/dev/null |
                                    grep "^${username}:" | \
                                    sed -e 's/[^:]*:[^:]*://' -e 's/:.*$//'`
                            if [ ".$userid" = . ]; then
                                userid='?'
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi

    #   determine (primary) group id
    groupid=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%[gG]'`" != . ]; then
        groupid="`(id -g ${username}) 2>/dev/null`"
        if [ ".$groupid" = . ]; then
            str="`(id) 2>/dev/null`"
            if [ ".`echo $str | grep 'gid[ 	]*=[ 	]*[0-9]*('`" != . ]; then
                groupid=`echo $str | sed -e 's/^.*gid[ 	]*=[ 	]*//' -e 's/(.*$//'`
            fi
            if [ ".$groupid" = . ]; then
                groupid=`(getent passwd ${username}) 2>/dev/null | \
                         sed -e 's/[^:]*:[^:]*:[^:]*://' -e 's/:.*$//'`
                if [ ".$groupid" = . ]; then
                    groupid=`grep "^${username}:" /etc/passwd 2>/dev/null | \
                             sed -e 's/[^:]*:[^:]*:[^:]*://' -e 's/:.*$//'`
                    if [ ".$groupid" = . ]; then
                        groupid=`(ypcat passwd) 2>/dev/null | grep "^${username}:" | \
                                 sed -e 's/[^:]*:[^:]*:[^:]*://' -e 's/:.*$//'`
                        if [ ".$groupid" = . ]; then
                            groupid='?'
                        fi
                    fi
                fi
            fi
        fi
    fi

    #   determine (primary) group name
    groupname=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%g'`" != . ]; then
        groupname="`(id -gn ${username}) 2>/dev/null`"
        if [ ".$groupname" = . ]; then
            str="`(id) 2>/dev/null`"
            if [ ".`echo $str | grep 'gid[ 	]*=[ 	]*[0-9]*('`" != . ]; then
                groupname=`echo $str | sed -e 's/^.*gid[ 	]*=[ 	]*[0-9]*(//' -e 's/).*$//'`
            fi
            if [ ".$groupname" = . ]; then
                groupname=`(getent group) 2>/dev/null | \
                           grep "^[^:]*:[^:]*:${groupid}:" | \
                           sed -e 's/:.*$//'`
                if [ ".$groupname" = . ]; then
                    groupname=`grep "^[^:]*:[^:]*:${groupid}:" /etc/group 2>/dev/null | \
                               sed -e 's/:.*$//'`
                    if [ ".$groupname" = . ]; then
                        groupname=`(ypcat group) 2>/dev/null | \
                                   grep "^[^:]*:[^:]*:${groupid}:" | \
                                   sed -e 's/:.*$//'`
                        if [ ".$groupname" = . ]; then
                            groupname='?'
                        fi
                    fi
                fi
            fi
        fi
    fi

    #   determine host and domain name
    hostname=''
    domainname=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%h'`" != . ]; then
        hostname="`(uname -n) 2>/dev/null |\
                   awk '{ printf("%s", $1); }'`"
        if [ ".$hostname" = . ]; then
            hostname="`(hostname) 2>/dev/null |\
                       awk '{ printf("%s", $1); }'`"
            if [ ".$hostname" = . ]; then
                hostname='unknown'
            fi
        fi
        case $hostname in
            *.* )
                domainname=".`echo $hostname | cut -d. -f2-`"
                hostname="`echo $hostname | cut -d. -f1`"
                ;;
        esac
    fi
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%d'`" != . ]; then
        if [ ".$domainname" = . ]; then
            if [ -f /etc/resolv.conf ]; then
                domainname="`grep '^[ 	]*domain' /etc/resolv.conf | sed -e 'q' |\
                             sed -e 's/.*domain//' \
                                 -e 's/^[ 	]*//' -e 's/^ *//' -e 's/^	*//' \
                                 -e 's/^\.//' -e 's/^/./' |\
                             awk '{ printf("%s", $1); }'`"
                if [ ".$domainname" = . ]; then
                    domainname="`grep '^[ 	]*search' /etc/resolv.conf | sed -e 'q' |\
                                 sed -e 's/.*search//' \
                                     -e 's/^[ 	]*//' -e 's/^ *//' -e 's/^	*//' \
                                     -e 's/ .*//' -e 's/	.*//' \
                                     -e 's/^\.//' -e 's/^/./' |\
                                 awk '{ printf("%s", $1); }'`"
                fi
            fi
        fi
    fi

    #   determine current time
    time_day=''
    time_month=''
    time_year=''
    time_monthname=''
    if [ ".$opt_e" = .yes ] && [ ".`echo $text | grep '%[DMYm]'`" != . ]; then
        time_day=`date '+%d'`
        time_month=`date '+%m'`
        time_year=`date '+%Y' 2>/dev/null`
        if [ ".$time_year" = . ]; then
            time_year=`date '+%y'`
            case $time_year in
                [5-9][0-9]) time_year="19$time_year" ;;
                [0-4][0-9]) time_year="20$time_year" ;;
            esac
        fi
        case $time_month in
            1|01) time_monthname='Jan' ;;
            2|02) time_monthname='Feb' ;;
            3|03) time_monthname='Mar' ;;
            4|04) time_monthname='Apr' ;;
            5|05) time_monthname='May' ;;
            6|06) time_monthname='Jun' ;;
            7|07) time_monthname='Jul' ;;
            8|08) time_monthname='Aug' ;;
            9|09) time_monthname='Sep' ;;
              10) time_monthname='Oct' ;;
              11) time_monthname='Nov' ;;
              12) time_monthname='Dec' ;;
        esac
    fi

    #   expand special ``%x'' constructs
    if [ ".$opt_e" = .yes ]; then
        text=`echo $seo "$text" |\
              sed -e "s/%B/${term_bold}/g" \
                  -e "s/%b/${term_norm}/g" \
                  -e "s/%u/${username}/g" \
                  -e "s/%U/${userid}/g" \
                  -e "s/%g/${groupname}/g" \
                  -e "s/%G/${groupid}/g" \
                  -e "s/%h/${hostname}/g" \
                  -e "s/%d/${domainname}/g" \
                  -e "s/%D/${time_day}/g" \
                  -e "s/%M/${time_month}/g" \
                  -e "s/%Y/${time_year}/g" \
                  -e "s/%m/${time_monthname}/g" 2>/dev/null`
    fi

    #   create output
    if [ .$opt_n = .no ]; then
        echo $seo "$text"
    else
        #   the harder part: echo -n is best, because
        #   awk may complain about some \xx sequences.
        if [ ".$minusn" != . ]; then
            echo $seo $minusn "$text"
        else
            echo dummy | awk '{ printf("%s", TEXT); }' TEXT="$text"
        fi
    fi

    shtool_exit 0
    ;;

move )
    ##
    ##  move -- Move files with simultaneous substitution
    ##  Copyright (c) 1999-2006 Ralf S. Engelschall <rse@engelschall.com>
    ##

    src="$1"
    dst="$2"

    #   consistency checks
    if [ ".$src" = . ] || [ ".$dst" = . ]; then
        echo "$msgprefix:Error: Invalid arguments" 1>&2
        shtool_exit 1
    fi
    if [ ".$src" = ".$dst" ]; then
        echo "$msgprefix:Error: Source and destination files are the same" 1>&2
        shtool_exit 1
    fi
    expsrc="$src"
    if [ ".$opt_e" = .yes ]; then
        expsrc="`echo $expsrc`"
    fi
    if [ ".$opt_e" = .yes ]; then
        if [ ".`echo "$src" | sed -e 's;^.*\\*.*$;;'`" = ".$src" ]; then
            echo "$msgprefix:Error: Source doesn't contain wildcard ('*'): $dst" 1>&2
            shtool_exit 1
        fi
        if [ ".`echo "$dst" | sed -e 's;^.*%[1-9].*$;;'`" = ".$dst" ]; then
            echo "$msgprefix:Error: Destination doesn't contain substitution ('%N'): $dst" 1>&2
            shtool_exit 1
        fi
        if [ ".$expsrc" = ".$src" ]; then
            echo "$msgprefix:Error: Sources not found or no asterisk : $src" 1>&2
            shtool_exit 1
        fi
    else
        if [ ! -r "$src" ]; then
            echo "$msgprefix:Error: Source not found: $src" 1>&2
            shtool_exit 1
        fi
    fi

    #   determine substitution patterns
    if [ ".$opt_e" = .yes ]; then
        srcpat=`echo "$src" | sed -e 's/\\./\\\\./g' -e 's/;/\\;/g' -e 's;\\*;\\\\(.*\\\\);g'`
        dstpat=`echo "$dst" | sed -e 's;%\([1-9]\);\\\\\1;g'`
    fi

    #   iterate over source(s)
    for onesrc in $expsrc; do
        if [ .$opt_e = .yes ]; then
            onedst=`echo $onesrc | sed -e "s;$srcpat;$dstpat;"`
        else
            onedst="$dst"
        fi
        errorstatus=0
        if [ ".$opt_v" = .yes ]; then
            echo "$onesrc -> $onedst"
        fi
        if [ ".$opt_p" = .yes ]; then
            if [ -r $onedst ]; then
                if cmp -s $onesrc $onedst; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "rm -f $onesrc" 1>&2
                    fi
                    rm -f $onesrc || errorstatus=$?
                else
                    if [ ".$opt_t" = .yes ]; then
                        echo "mv -f $onesrc $onedst" 1>&2
                    fi
                    mv -f $onesrc $onedst || errorstatus=$?
                fi
            else
                if [ ".$opt_t" = .yes ]; then
                    echo "mv -f $onesrc $onedst" 1>&2
                fi
                mv -f $onesrc $onedst || errorstatus=$?
            fi
        else
            if [ ".$opt_t" = .yes ]; then
                echo "mv -f $onesrc $onedst" 1>&2
            fi
            mv -f $onesrc $onedst || errorstatus=$?
        fi
        if [ $errorstatus -ne 0 ]; then
            break;
        fi
    done

    shtool_exit $errorstatus
    ;;

install )
    ##
    ##  install -- Install a program, script or datafile
    ##  Copyright (c) 1997-2006 Ralf S. Engelschall <rse@engelschall.com>
    ##

    #   special case: "shtool install -d <dir> [...]" internally
    #   maps to "shtool mkdir -f -p -m 755 <dir> [...]"
    if [ "$opt_d" = yes ]; then
        cmd="$0 mkdir -f -p -m 755"
        if [ ".$opt_o" != . ]; then
            cmd="$cmd -o '$opt_o'"
        fi
        if [ ".$opt_g" != . ]; then
            cmd="$cmd -g '$opt_g'"
        fi
        if [ ".$opt_v" = .yes ]; then
            cmd="$cmd -v"
        fi
        if [ ".$opt_t" = .yes ]; then
            cmd="$cmd -t"
        fi
        for dir in "$@"; do
            eval "$cmd $dir" || shtool_exit $?
        done
        shtool_exit 0
    fi

    #   determine source(s) and destination
    argc=$#
    srcs=""
    while [ $# -gt 1 ]; do
        srcs="$srcs $1"
        shift
    done
    dstpath="$1"

    #   type check for destination
    dstisdir=0
    if [ -d $dstpath ]; then
        dstpath=`echo "$dstpath" | sed -e 's:/$::'`
        dstisdir=1
    fi

    #   consistency check for destination
    if [ $argc -gt 2 ] && [ $dstisdir = 0 ]; then
        echo "$msgprefix:Error: multiple sources require destination to be directory" 1>&2
        shtool_exit 1
    fi

    #   iterate over all source(s)
    for src in $srcs; do
        dst=$dstpath

        #   if destination is a directory, append the input filename
        if [ $dstisdir = 1 ]; then
            dstfile=`echo "$src" | sed -e 's;.*/\([^/]*\)$;\1;'`
            dst="$dst/$dstfile"
        fi

        #   check for correct arguments
        if [ ".$src" = ".$dst" ]; then
            echo "$msgprefix:Warning: source and destination are the same - skipped" 1>&2
            continue
        fi
        if [ -d "$src" ]; then
            echo "$msgprefix:Warning: source \`$src' is a directory - skipped" 1>&2
            continue
        fi

        #   make a temp file name in the destination directory
        dsttmp=`echo $dst |\
                sed -e 's;[^/]*$;;' -e 's;\(.\)/$;\1;' -e 's;^$;.;' \
                    -e "s;\$;/#INST@$$#;"`

        #   verbosity
        if [ ".$opt_v" = .yes ]; then
            echo "$src -> $dst" 1>&2
        fi

        #   copy or move the file name to the temp name
        #   (because we might be not allowed to change the source)
        if [ ".$opt_C" = .yes ]; then
            opt_c=yes
        fi
        if [ ".$opt_c" = .yes ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "cp $src $dsttmp" 1>&2
            fi
            cp $src $dsttmp || shtool_exit $?
        else
            if [ ".$opt_t" = .yes ]; then
                echo "mv $src $dsttmp" 1>&2
            fi
            mv $src $dsttmp || shtool_exit $?
        fi

        #   adjust the target file
        if [ ".$opt_e" != . ]; then
            sed='sed'
            OIFS="$IFS"; IFS="$ASC_NL"; set -- $opt_e; IFS="$OIFS"
            for e
            do
                sed="$sed -e '$e'"
            done
            cp $dsttmp $dsttmp.old
            chmod u+w $dsttmp
            eval "$sed <$dsttmp.old >$dsttmp" || shtool_exit $?
            rm -f $dsttmp.old
        fi
        if [ ".$opt_s" = .yes ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "strip $dsttmp" 1>&2
            fi
            strip $dsttmp || shtool_exit $?
        fi
        if [ ".$opt_o" != . ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "chown $opt_o $dsttmp" 1>&2
            fi
            chown $opt_o $dsttmp || shtool_exit $?
        fi
        if [ ".$opt_g" != . ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "chgrp $opt_g $dsttmp" 1>&2
            fi
            chgrp $opt_g $dsttmp || shtool_exit $?
        fi
        if [ ".$opt_m" != ".-" ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "chmod $opt_m $dsttmp" 1>&2
            fi
            chmod $opt_m $dsttmp || shtool_exit $?
        fi

        #   determine whether to do a quick install
        #   (has to be done _after_ the strip was already done)
        quick=no
        if [ ".$opt_C" = .yes ]; then
            if [ -r $dst ]; then
                if cmp -s $src $dst; then
                    quick=yes
                fi
            fi
        fi

        #   finally, install the file to the real destination
        if [ $quick = yes ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "rm -f $dsttmp" 1>&2
            fi
            rm -f $dsttmp
        else
            if [ ".$opt_t" = .yes ]; then
                echo "rm -f $dst && mv $dsttmp $dst" 1>&2
            fi
            rm -f $dst && mv $dsttmp $dst
        fi
    done

    shtool_exit 0
    ;;

mkdir )
    ##
    ##  mkdir -- Make one or more directories
    ##  Copyright (c) 1996-2006 Ralf S. Engelschall <rse@engelschall.com>
    ##

    errstatus=0
    for p in ${1+"$@"}; do
        #   if the directory already exists...
        if [ -d "$p" ]; then
            if [ ".$opt_f" = .no ] && [ ".$opt_p" = .no ]; then
                echo "$msgprefix:Error: directory already exists: $p" 1>&2
                errstatus=1
                break
            else
                continue
            fi
        fi
        #   if the directory has to be created...
        if [ ".$opt_p" = .no ]; then
            if [ ".$opt_t" = .yes ]; then
                echo "mkdir $p" 1>&2
            fi
            mkdir $p || errstatus=$?
            if [ ".$opt_o" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "chown $opt_o $p" 1>&2
                fi
                chown $opt_o $p || errstatus=$?
            fi
            if [ ".$opt_g" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "chgrp $opt_g $p" 1>&2
                fi
                chgrp $opt_g $p || errstatus=$?
            fi
            if [ ".$opt_m" != . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "chmod $opt_m $p" 1>&2
                fi
                chmod $opt_m $p || errstatus=$?
            fi
        else
            #   the smart situation
            set fnord `echo ":$p" |\
                       sed -e 's/^:\//%/' \
                           -e 's/^://' \
                           -e 's/\// /g' \
                           -e 's/^%/\//'`
            shift
            pathcomp=''
            for d in ${1+"$@"}; do
                pathcomp="$pathcomp$d"
                case "$pathcomp" in
                    -* ) pathcomp="./$pathcomp" ;;
                esac
                if [ ! -d "$pathcomp" ]; then
                    if [ ".$opt_t" = .yes ]; then
                        echo "mkdir $pathcomp" 1>&2
                    fi
                    mkdir $pathcomp || errstatus=$?
                    if [ ".$opt_o" != . ]; then
                        if [ ".$opt_t" = .yes ]; then
                            echo "chown $opt_o $pathcomp" 1>&2
                        fi
                        chown $opt_o $pathcomp || errstatus=$?
                    fi
                    if [ ".$opt_g" != . ]; then
                        if [ ".$opt_t" = .yes ]; then
                            echo "chgrp $opt_g $pathcomp" 1>&2
                        fi
                        chgrp $opt_g $pathcomp || errstatus=$?
                    fi
                    if [ ".$opt_m" != . ]; then
                        if [ ".$opt_t" = .yes ]; then
                            echo "chmod $opt_m $pathcomp" 1>&2
                        fi
                        chmod $opt_m $pathcomp || errstatus=$?
                    fi
                fi
                pathcomp="$pathcomp/"
            done
        fi
    done

    shtool_exit $errstatus
    ;;

mkln )
    ##
    ##  mkln -- Make link with calculation of relative paths
    ##  Copyright (c) 1998-2006 Ralf S. Engelschall <rse@engelschall.com>
    ##

    #   determine source(s) and destination
    args=$?
    srcs=""
    while [ $# -gt 1 ]; do
        srcs="$srcs $1"
        shift
    done
    dst="$1"
    if [ ! -d $dst ]; then
        if [ $args -gt 2 ]; then
            echo "$msgprefix:Error: multiple sources not allowed when target isn't a directory" 1>&2
            shtool_exit 1
        fi
    fi

    #   determine link options
    lnopt=""
    if [ ".$opt_f" = .yes ]; then
        lnopt="$lnopt -f"
    fi
    if [ ".$opt_s" = .yes ]; then
        lnopt="$lnopt -s"
    fi

    #   iterate over sources
    for src in $srcs; do
        #   determine if one of the paths is an absolute path,
        #   because then we _have_ to use an absolute symlink
        oneisabs=0
        srcisabs=0
        dstisabs=0
        case $src in
            /* ) oneisabs=1; srcisabs=1 ;;
        esac
        case $dst in
            /* ) oneisabs=1; dstisabs=1 ;;
        esac

        #   split source and destination into dir and base name
        if [ -d $src ]; then
            srcdir=`echo $src | sed -e 's;/*$;;'`
            srcbase=""
        else
            srcdir=`echo  $src | sed -e 's;^[^/]*$;;' -e 's;^\(.*/\)[^/]*$;\1;' -e 's;\(.\)/$;\1;'`
            srcbase=`echo $src | sed -e 's;.*/\([^/]*\)$;\1;'`
        fi
        if [ -d $dst ]; then
            dstdir=`echo $dst | sed -e 's;/*$;;'`
            dstbase=""
        else
            dstdir=`echo  $dst | sed -e 's;^[^/]*$;;' -e 's;^\(.*/\)[^/]*$;\1;' -e 's;\(.\)/$;\1;'`
            dstbase=`echo $dst | sed -e 's;.*/\([^/]*\)$;\1;'`
        fi

        #   consistency check
        if [ ".$dstdir" != . ]; then
            if [ ! -d $dstdir ]; then
                echo "$msgprefix:Error: destination directory not found: $dstdir" 1>&2
                shtool_exit 1
            fi
        fi

        #   make sure the source is reachable from the destination
        if [ $dstisabs = 1 ]; then
            if [ $srcisabs = 0 ]; then
                if [ ".$srcdir" = . ]; then
                    srcdir="`pwd | sed -e 's;/*$;;'`"
                    srcisabs=1
                    oneisabs=1
                elif [ -d $srcdir ]; then
                    srcdir="`cd $srcdir; pwd | sed -e 's;/*$;;'`"
                    srcisabs=1
                    oneisabs=1
                fi
            fi
        fi

        #   split away a common prefix
        prefix=""
        if [ ".$srcdir" = ".$dstdir" ] && [ ".$srcdir" != . ]; then
            prefix="$srcdir/"
            srcdir=""
            dstdir=""
        else
            while [ ".$srcdir" != . ] && [ ".$dstdir" != . ]; do
                presrc=`echo $srcdir | sed -e 's;^\([^/]*\)/.*;\1;'`
                predst=`echo $dstdir | sed -e 's;^\([^/]*\)/.*;\1;'`
                if [ ".$presrc" != ".$predst" ]; then
                    break
                fi
                prefix="$prefix$presrc/"
                srcdir=`echo $srcdir | sed -e 's;^[^/]*/*;;'`
                dstdir=`echo $dstdir | sed -e 's;^[^/]*/*;;'`
            done
        fi

        #   destination prefix is just the common prefix
        dstpre="$prefix"

        #   determine source prefix which is the reverse directory
        #   step-up corresponding to the destination directory
        srcpre=""

        isroot=0
        if [ ".$prefix" = . ] || [ ".$prefix" = ./ ]; then
            isroot=1
        fi
        if [ $oneisabs = 0 ] || [ $isroot = 0 ]; then
            pl="$dstdir/"
            OIFS="$IFS"; IFS='/'
            for pe in $pl; do
                [ ".$pe" = .  ] && continue
                [ ".$pe" = .. ] && continue
                srcpre="../$srcpre"
            done
            IFS="$OIFS"
        else
            if [ $srcisabs = 1 ]; then
                srcpre="$prefix"
            fi
        fi

        #   determine destination symlink name
        if [ ".$dstbase" = . ]; then
            if [ ".$srcbase" != . ]; then
                dstbase="$srcbase"
            else
                dstbase=`echo "$prefix$srcdir" | sed -e 's;/*$;;' -e 's;.*/\([^/]*\)$;\1;'`
            fi
        fi

        #   now finalize source and destination directory paths
        srcdir=`echo $srcdir | sed -e 's;\([^/]\)$;\1/;'`
        dstdir=`echo $dstdir | sed -e 's;\([^/]\)$;\1/;'`

        #   run the final link command
        if [ ".$opt_t" = .yes ]; then
            echo "ln$lnopt $srcpre$srcdir$srcbase $dstpre$dstdir$dstbase"
        fi
        eval ln$lnopt $srcpre$srcdir$srcbase $dstpre$dstdir$dstbase
    done

    shtool_exit 0
    ;;

subst )
    ##
    ##  subst -- Apply sed(1) substitution operations
    ##  Copyright (c) 2001-2006 Ralf S. Engelschall <rse@engelschall.com>
    ##

    #   remember optional list of file(s)
    files="$*"
    files_num="$#"

    #   parameter consistency check
    if [ $# -eq 0 ] && [ ".$opt_b" != . ]; then
        echo "$msgprefix:Error: option -b cannot be applied to stdin" 1>&2
        shtool_exit 1
    fi
    if [ $# -eq 0 ] && [ ".$opt_s" = .yes ]; then
        echo "$msgprefix:Error: option -s cannot be applied to stdin" 1>&2
        shtool_exit 1
    fi

    #   build underlying sed(1) command
    sedcmd='sed'
    if [ ".$opt_e" != . ]; then
        OIFS="$IFS"; IFS="$ASC_NL"; set -- $opt_e; IFS="$OIFS"
        for e
        do
            sedcmd="$sedcmd -e '$e'"
        done
    elif [ ".$opt_f" != . ]; then
        if [ ! -f $opt_f ]; then
            echo "$msgprefix:Error: command file \`$opt_f' not found or not a regular file" 1>&2
            shtool_exit 1
        fi
        sedcmd="$sedcmd -f '$opt_f'"
    else
        echo "$msgprefix:Error: either -e option(s) or -f option required" 1>&2
        shtool_exit 1
    fi

    #   determine extension for original file
    orig=".orig"
    if [ ".$opt_b" != . ]; then
        orig="$opt_b"
    fi

    #   apply sed(1) operation(s)
    if [ ".$files" != . ]; then
        #   apply operation(s) to files
        substdone=no
        for file in $files; do
            test ".$file" = . && continue
            if [ ! -f $file ]; then
                echo "$msgprefix:Warning: file \`$file' not found or not a regular file" 1>&2
                continue
            fi

            #   handle interactive mode
            if [ ".$opt_i" = .yes ]; then
                eval "$sedcmd <$file >$file.new"
                skip=no
                if cmp $file $file.new >/dev/null 2>&1; then
                    rm -f $file.new
                    skip=yes
                else
                    (diff -U1 $file $file.new >$tmpfile) 2>/dev/null
                    if [ ".`cat $tmpfile`" = . ]; then
                        (diff -C1 $file $file.new >$tmpfile) 2>/dev/null
                        if [ ".`cat $tmpfile`" = . ]; then
                            echo "$msgprefix:Warning: unable to show difference for file \`$file'" 1>&2
                            cp /dev/null $tmpfile
                        fi
                    fi
                    rm -f $file.new
                    cat $tmpfile
                    echo dummy | awk '{ printf("%s", TEXT); }' TEXT=">>> Apply [Y/n]: "
                    read input
                    if [ ".$input" != .Y ] &&\
                       [ ".$input" != .y ] &&\
                       [ ".$input" != . ]; then
                       skip=yes
                    fi
                fi
                if [ ".$skip" = .yes ]; then
                    if [ ".$opt_v" = .yes ]; then
                        echo "file \`$file' -- skipped" 1>&2
                    fi
                    continue
                fi
            fi

            #   apply sed(1) operation(s)
            if [ ".$opt_v" = .yes ]; then
                echo "patching \`$file'" 1>&2
            fi
            if [ ".$opt_t" = .yes ]; then
                echo "\$ cp -p $file $file$orig"
                echo "\$ chmod u+w $file"
                echo "\$ $sedcmd <$file$orig >$file"
            fi
            if [ ".$opt_n" = .no ]; then
                cp -p $file $file$orig
                chmod u+w $file >/dev/null 2>&1 || true
                eval "$sedcmd <$file$orig >$file"
            fi

            #   optionally fix timestamp
            if [ ".$opt_s" = .yes ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "\$ touch -r $file$orig $file"
                fi
                if [ ".$opt_n" = .no ]; then
                    touch -r $file$orig $file
                fi
            fi

            #   optionally check whether any content change actually occurred 
            if [ ".$opt_q" = .no ]; then
                if cmp $file$orig $file >/dev/null 2>&1; then
                    if [ ".$opt_w" = .yes ]; then
                        echo "$msgprefix:Warning: substitution resulted in no content change on file \"$file\"" 1>&2
                    fi
                else
                    substdone=yes
                fi
            fi

            #   optionally remove preserved original file
            if [ ".$opt_b" = . ]; then
                if [ ".$opt_t" = .yes ]; then
                    echo "\$ rm -f $file$orig"
                fi
                if [ ".$opt_n" = .no ]; then
                    rm -f $file$orig
                fi
            fi
        done
        if [ ".$opt_q" = .no ] && [ ".$opt_w" = .no ]; then
            if [ ".$substdone" = .no ]; then
                if [ ".$files_num" = .1 ]; then
                    echo "$msgprefix:Warning: substitution resulted in no content change on file \"$file\"" 1>&2
                else
                    echo "$msgprefix:Warning: substitution resulted in no content change on any file" 1>&2
                fi
            fi
        fi
    else
        #   apply operation(s) to stdin/stdout
        if [ ".$opt_v" = .yes ]; then
            echo "patching <stdin>" 1>&2
        fi
        if [ ".$opt_t" = .yes ]; then
            echo "\$ $sedcmd"
        fi
        if [ ".$opt_n" = .no ]; then
            eval "$sedcmd"
        fi
    fi

    shtool_exit 0
    ;;

esac

shtool_exit 0

