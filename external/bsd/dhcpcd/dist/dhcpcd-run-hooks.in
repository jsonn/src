#!/bin/sh
# dhcpcd client configuration script 

# Handy variables and functions for our hooks to use
from="from"
signature_base="# Generated by dhcpcd"
signature="${signature_base} ${from} ${interface}"
signature_base_end="# End of dhcpcd"
signature_end="${signature_base_end} ${from} ${interface}"
state_dir="/var/run/dhcpcd"

# Ensure that all arguments are unique
uniqify()
{
	local result=

	while [ -n "$1" ]; do
		case " ${result} " in
		*" $1 "*);;
		*) result="${result}${result:+ }$1";;
		esac
		shift
	done
	echo "${result}"
}

# List interface config files in a dir
# We may wish to control the order at some point rather than just lexical
list_interfaces()
{
	local x= interfaces=
	for x in "$1"/*; do
		[ -e "${x}" ] || continue
		interfaces="${interfaces}${interfaces:+ }${x##*/}"
	done
	echo "${interfaces}"
}

# We normally use sed to extract values using a key from a list of files
# but sed may not always be available at the time.
key_get_value()
{
	local key="$1" value= x= line=

	shift
	if type sed >/dev/null 2>&1; then
		sed -n "s/^${key}//p" $@
	else
		for x; do
			while read line; do
				case "${line}" in
				"${key}"*) echo "${line##${key}}";;
				esac
			done < "${x}"
		done
	fi
}

# We normally use sed to remove markers from a configuration file
# but sed may not always be available at the time.
remove_markers()
{
	local m1="$1" m2="$2" x= line= in_marker=0

	shift; shift
	if type sed >/dev/null 2>&1; then
		sed "/^${m1}/,/^${m2}/d" $@
	else
		for x; do
			while read line; do
				case "${line}" in
				"${m1}"*) in_marker=1;;
				"${m2}"*) in_marker=0;;
				*) [ ${in_marker} = 0 ] && echo "${line}";;
				esac
			done < "${x}"
		done
	fi
}

# Compare two files
# It different, replace first with second otherwise remove second
change_file()
{
	if type cmp >/dev/null 2>&1; then
		cmp -s "$1" "$2"
	elif type diff >/dev/null 2>&1; then
		diff -q "$1" "$2" >/dev/null
	else
		# Hopefully we're only working on small text files ...
		[ "$(cat "$1")" = "$(cat "$2")" ]
	fi
	if [ $? -eq 0 ]; then
		rm -f "$2"
		return 1
	fi
	mv -f "$2" "$1"
	return 0
}

# Save a config file
save_conf()
{
	if [ -f "$1" ]; then
		rm -f "$1"-pre."${interface}"
		mv -f "$1" "$1"-pre."${interface}"
	fi
}

# Restore a config file
restore_conf()
{
	[ -f "$1"-pre."${interface}" ] || return 1
	rm -f "$1"
	mv -f "$1"-pre."${interface}" "$1"
}


# We source each script into this one so that scripts run earlier can
# remove variables from the environment so later scripts don't see them.
# Thus, the user can create their dhcpcd.enter/exit-hook script to configure
# /etc/resolv.conf how they want and stop the system scripts ever updating it.
for hook in \
	@SYSCONFDIR@/dhcpcd.enter-hook \
	@HOOKDIR@/* \
	@SYSCONFDIR@/dhcpcd.exit-hook
do
	for skip in ${skip_hooks}; do
		case "${hook}" in
			"${skip}")			continue 2;;
			*/[0-9][0-9]"-${skip}")		continue 2;;
			*/[0-9][0-9]"-${skip}.sh")	continue 2;;
		esac
	done
	if [ -f "${hook}" ]; then
		. "${hook}"
	fi
done
